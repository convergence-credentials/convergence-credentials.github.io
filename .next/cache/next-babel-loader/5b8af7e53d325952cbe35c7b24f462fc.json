{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime-corejs2/helpers/esm/taggedTemplateLiteral\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _marked =\n/*#__PURE__*/\n_regeneratorRuntime.mark(loadCertificateContracts),\n    _marked2 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(isValidENSDomain),\n    _marked3 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(isValidSmartContract),\n    _marked4 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateStore),\n    _marked5 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateHash),\n    _marked6 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateIssued),\n    _marked7 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateNotRevoked),\n    _marked8 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(lookupAddressOnRegistry),\n    _marked9 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(resolveEnsNameToText),\n    _marked10 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateDnsIssuer),\n    _marked11 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateRegistryIssuer),\n    _marked12 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(getDetailedIssuerStatus),\n    _marked13 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateIssuer),\n    _marked14 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificate),\n    _marked15 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(sendCertificate),\n    _marked16 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(networkReset),\n    _marked17 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(getAnalyticsDetails),\n    _marked18 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(triggerAnalytics),\n    _marked19 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsIssuerFail),\n    _marked20 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsHashFail),\n    _marked21 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsIssuedFail),\n    _marked22 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsRevocationFail),\n    _marked23 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsStoreFail);\n\nimport { some, get, partition, compact, mapKeys } from \"lodash\";\nimport { put, all, call, select, takeEvery } from \"redux-saga/effects\";\nimport { getData, verifySignature } from \"@govtechsg/open-attestation\";\nimport { isValidAddress as isEthereumAddress } from \"ethereumjs-util\";\nimport Router from \"next/router\";\nimport { getDocumentStoreRecords } from \"@govtechsg/dnsprove\";\nimport { getLogger } from \"../utils/logger\";\nimport { types, verifyingCertificateIssuerSuccess, verifyingCertificateIssuerFailure, verifyingCertificateRevocationSuccess, verifyingCertificateRevocationFailure, verifyingCertificateIssuedSuccess, verifyingCertificateIssuedFailure, verifyingCertificateHashSuccess, verifyingCertificateHashFailure, verifyingCertificateStoreSuccess, verifyingCertificateStoreFailure, getCertificate } from \"../reducers/certificate\";\nimport { types as applicationTypes } from \"../reducers/application\";\nimport DocumentStoreDefinition from \"../services/contracts/DocumentStore.json\";\nimport fetchIssuers from \"../services/issuers\";\nimport { combinedHash } from \"../utils\";\nimport { ensResolveAddress, getText } from \"../services/ens\";\nimport sendEmail from \"../services/email\";\nimport { analyticsEvent } from \"../components/Analytics\";\nimport { getDocumentStore, getDocumentIssuerStores } from \"../utils/certificate\";\nimport { getSelectedWeb3 } from \"./application\";\nimport { IS_MAINNET } from \"../config\";\n\nvar _getLogger = getLogger(\"saga:certificate\"),\n    trace = _getLogger.trace,\n    error = _getLogger.error;\n\nvar ANALYTICS_VERIFICATION_ERROR_CODE = {\n  ISSUER_IDENTITY: 0,\n  CERTIFICATE_HASH: 1,\n  UNISSUED_CERTIFICATE: 2,\n  REVOKED_CERTIFICATE: 3,\n  CERTIFICATE_STORE: 4\n};\nexport function loadCertificateContracts(_ref) {\n  var payload, data, unresolvedContractStoreAddresses, web3, contractStoreAddresses, abi, contracts;\n  return _regeneratorRuntime.wrap(function loadCertificateContracts$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          payload = _ref.payload;\n          _context.prev = 1;\n          data = getData(payload);\n          trace(\"Loading certificate: \".concat(data));\n          unresolvedContractStoreAddresses = get(data, \"issuers\", []).map(function (issuer) {\n            return getDocumentStore(issuer);\n          });\n          _context.next = 7;\n          return getSelectedWeb3();\n\n        case 7:\n          web3 = _context.sent;\n          _context.next = 10;\n          return all(unresolvedContractStoreAddresses.map(function (unresolvedAddress) {\n            return call(ensResolveAddress, unresolvedAddress);\n          }));\n\n        case 10:\n          contractStoreAddresses = _context.sent;\n          trace(\"Resolved certificate's store addresses, \".concat(contractStoreAddresses));\n          abi = DocumentStoreDefinition.abi;\n          contracts = contractStoreAddresses.map(function (address) {\n            return new web3.eth.Contract(abi, address);\n          });\n          _context.next = 16;\n          return put({\n            type: types.LOADING_STORE_SUCCESS\n          });\n\n        case 16:\n          return _context.abrupt(\"return\", contracts);\n\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context[\"catch\"](1);\n          _context.next = 23;\n          return put({\n            type: types.LOADING_STORE_FAILURE,\n            payload: _context.t0\n          });\n\n        case 23:\n          return _context.abrupt(\"return\", null);\n\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 19]]);\n}\nexport function isValidENSDomain(storeAddress) {\n  var web3, ensToAddress;\n  return _regeneratorRuntime.wrap(function isValidENSDomain$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          trace(\"Checking if \".concat(storeAddress, \" is a valid ENS Domain\"));\n\n          if (!(storeAddress == null)) {\n            _context2.next = 3;\n            break;\n          }\n\n          throw new Error(\"No address in certificate\");\n\n        case 3:\n          _context2.next = 5;\n          return getSelectedWeb3();\n\n        case 5:\n          web3 = _context2.sent;\n          _context2.next = 8;\n          return web3.eth.ens.getAddress(storeAddress);\n\n        case 8:\n          ensToAddress = _context2.sent;\n\n          if (!(ensToAddress === null)) {\n            _context2.next = 11;\n            break;\n          }\n\n          throw new Error(\"Invalid ENS\");\n\n        case 11:\n          return _context2.abrupt(\"return\", ensToAddress);\n\n        case 12:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\nexport function isValidSmartContract(storeAddress) {\n  var web3, supportedContractHashes, onChainByteCode, hashOfOnChainByteCode;\n  return _regeneratorRuntime.wrap(function isValidSmartContract$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return getSelectedWeb3();\n\n        case 2:\n          web3 = _context3.sent;\n          supportedContractHashes = [\"0x7135575eac76f1817c27b06c452bdc2b7e1b13240797415684e227def063a127\"];\n          _context3.next = 6;\n          return web3.eth.getCode(storeAddress);\n\n        case 6:\n          onChainByteCode = _context3.sent;\n          hashOfOnChainByteCode = web3.utils.keccak256(onChainByteCode);\n\n          if (supportedContractHashes.includes(hashOfOnChainByteCode)) {\n            _context3.next = 10;\n            break;\n          }\n\n          throw new Error(\"Invalid smart contract: \"(_templateObject(), storeAddress));\n\n        case 10:\n          return _context3.abrupt(\"return\", true);\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}\nexport function verifyCertificateStore(_ref2) {\n  var certificate, data, contractStoreAddresses, _partition, _partition2, ethereumAddressIssuers, unresolvedEnsNames, resolvedEnsNames, combinedStoreAddresses;\n\n  return _regeneratorRuntime.wrap(function verifyCertificateStore$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          certificate = _ref2.certificate;\n          _context4.prev = 1;\n          data = getData(certificate);\n          contractStoreAddresses = get(data, \"issuers\", []).map(function (issuer) {\n            return getDocumentStore(issuer);\n          });\n          trace(\"Attempting to verify certificate store: \".concat(contractStoreAddresses));\n          _partition = partition(contractStoreAddresses, isEthereumAddress), _partition2 = _slicedToArray(_partition, 2), ethereumAddressIssuers = _partition2[0], unresolvedEnsNames = _partition2[1];\n          trace(\"ethereumAddressIssuers\", ethereumAddressIssuers);\n          trace(\"unresolvedEnsNames\", unresolvedEnsNames);\n          _context4.next = 10;\n          return unresolvedEnsNames.map(function (unresolvedEnsName) {\n            return call(isValidENSDomain, unresolvedEnsName);\n          });\n\n        case 10:\n          resolvedEnsNames = _context4.sent;\n          // Concat the 2 arrays\n          combinedStoreAddresses = compact(ethereumAddressIssuers.concat(resolvedEnsNames)); // Checks if issuing institution has a valid smart contract with OpenCerts\n\n          _context4.next = 14;\n          return combinedStoreAddresses.map(function (address) {\n            return isValidSmartContract(address);\n          });\n\n        case 14:\n          _context4.next = 16;\n          return put(verifyingCertificateStoreSuccess());\n\n        case 16:\n          return _context4.abrupt(\"return\", combinedStoreAddresses);\n\n        case 19:\n          _context4.prev = 19;\n          _context4.t0 = _context4[\"catch\"](1);\n          error(_context4.t0);\n          _context4.next = 24;\n          return put(verifyingCertificateStoreFailure({\n            error: _context4.t0.message\n          }));\n\n        case 24:\n          return _context4.abrupt(\"return\", false);\n\n        case 25:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4, null, [[1, 19]]);\n}\nexport function verifyCertificateHash(_ref3) {\n  var certificate, verified, hashError;\n  return _regeneratorRuntime.wrap(function verifyCertificateHash$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          certificate = _ref3.certificate;\n          verified = verifySignature(certificate);\n\n          if (!verified) {\n            _context5.next = 6;\n            break;\n          }\n\n          _context5.next = 5;\n          return put(verifyingCertificateHashSuccess());\n\n        case 5:\n          return _context5.abrupt(\"return\", true);\n\n        case 6:\n          hashError = new Error(\"Certificate data does not match target hash\");\n          error(hashError);\n          _context5.next = 10;\n          return put(verifyingCertificateHashFailure({\n            error: hashError.message\n          }));\n\n        case 10:\n          return _context5.abrupt(\"return\", false);\n\n        case 11:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5);\n}\nexport function verifyCertificateIssued(_ref4) {\n  var certificate, certificateStores, merkleRoot, issuedStatuses, isIssued;\n  return _regeneratorRuntime.wrap(function verifyCertificateIssued$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          certificate = _ref4.certificate, certificateStores = _ref4.certificateStores;\n          _context6.prev = 1;\n          merkleRoot = \"0x\".concat(get(certificate, \"signature.merkleRoot\", \"\")); // Checks if certificate has been issued on ALL store\n\n          _context6.next = 5;\n          return all(certificateStores.map(function (store) {\n            return store.methods.isIssued(merkleRoot).call();\n          }));\n\n        case 5:\n          issuedStatuses = _context6.sent;\n\n          if (!(issuedStatuses.length === 0)) {\n            _context6.next = 8;\n            break;\n          }\n\n          throw new Error(\"Invalid file\");\n\n        case 8:\n          isIssued = issuedStatuses.reduce(function (prev, curr) {\n            return prev && curr;\n          }, true);\n\n          if (isIssued) {\n            _context6.next = 11;\n            break;\n          }\n\n          throw new Error(\"Certificate has not been issued\");\n\n        case 11:\n          _context6.next = 13;\n          return put(verifyingCertificateIssuedSuccess());\n\n        case 13:\n          return _context6.abrupt(\"return\", true);\n\n        case 16:\n          _context6.prev = 16;\n          _context6.t0 = _context6[\"catch\"](1);\n          error(_context6.t0);\n          _context6.next = 21;\n          return put(verifyingCertificateIssuedFailure({\n            error: _context6.t0.message\n          }));\n\n        case 21:\n          return _context6.abrupt(\"return\", false);\n\n        case 22:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked6, null, [[1, 16]]);\n}\nexport var getIntermediateHashes = function getIntermediateHashes(targetHash) {\n  var proof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // Returns hash of all intermediate hashes from targetHash to merkleRoot\n  var intermediateHashes = [\"0x\".concat(targetHash)];\n  proof.reduce(function (accumulator, currentValue) {\n    var combined = combinedHash(accumulator, currentValue).toString(\"hex\");\n    intermediateHashes.push(\"0x\".concat(combined));\n    return combined;\n  }, targetHash);\n  return intermediateHashes;\n};\nexport function verifyCertificateNotRevoked(_ref5) {\n  var certificate, certificateStores, targetHash, proof, intermediateHashes, _loop, i;\n\n  return _regeneratorRuntime.wrap(function verifyCertificateNotRevoked$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          certificate = _ref5.certificate, certificateStores = _ref5.certificateStores;\n          _context8.prev = 1;\n          targetHash = get(certificate, \"signature.targetHash\", null);\n          proof = get(certificate, \"signature.proof\", null); // Checks if certificate and path towards merkle root has been revoked\n\n          intermediateHashes = getIntermediateHashes(targetHash, proof);\n          _loop =\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _loop(i) {\n            var hash, revokedStatus, isRevoked;\n            return _regeneratorRuntime.wrap(function _loop$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    hash = intermediateHashes[i]; // Check if certificate is revoked on ALL store\n\n                    _context7.next = 3;\n                    return all(certificateStores.map(function (store) {\n                      return store.methods.isRevoked(hash).call();\n                    }));\n\n                  case 3:\n                    revokedStatus = _context7.sent;\n                    isRevoked = revokedStatus.reduce(function (prev, curr) {\n                      return prev || curr;\n                    }, false);\n\n                    if (!isRevoked) {\n                      _context7.next = 7;\n                      break;\n                    }\n\n                    throw new Error(\"Certificate has been revoked, revoked hash: \".concat(hash));\n\n                  case 7:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _loop);\n          });\n          i = 0;\n\n        case 7:\n          if (!(i < intermediateHashes.length)) {\n            _context8.next = 12;\n            break;\n          }\n\n          return _context8.delegateYield(_loop(i), \"t0\", 9);\n\n        case 9:\n          i += 1;\n          _context8.next = 7;\n          break;\n\n        case 12:\n          _context8.next = 14;\n          return put(verifyingCertificateRevocationSuccess());\n\n        case 14:\n          return _context8.abrupt(\"return\", true);\n\n        case 17:\n          _context8.prev = 17;\n          _context8.t1 = _context8[\"catch\"](1);\n          error(_context8.t1);\n          _context8.next = 22;\n          return put(verifyingCertificateRevocationFailure({\n            error: _context8.t1.message\n          }));\n\n        case 22:\n          return _context8.abrupt(\"return\", false);\n\n        case 23:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, _marked7, null, [[1, 17]]);\n}\n\nfunction isApprovedENSDomain(issuerAddress) {\n  trace(\"Checking if \".concat(issuerAddress, \" is opencerts TLD\"));\n  var approvedENSDomains = [/(opencerts.eth)$/];\n  return some(approvedENSDomains.map(function (domainMask) {\n    return domainMask.test(issuerAddress.toLowerCase());\n  }));\n}\n\nexport function lookupAddressOnRegistry(ethereumAddressIssuer) {\n  var registeredIssuers, issuersNormalised, identity;\n  return _regeneratorRuntime.wrap(function lookupAddressOnRegistry$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.next = 2;\n          return fetchIssuers();\n\n        case 2:\n          registeredIssuers = _context9.sent;\n          issuersNormalised = mapKeys(registeredIssuers, function (_, k) {\n            return k.toUpperCase();\n          });\n          identity = issuersNormalised[ethereumAddressIssuer.toUpperCase()];\n\n          if (identity) {\n            _context9.next = 7;\n            break;\n          }\n\n          throw new Error(\"Issuer identity cannot be verified: \".concat(ethereumAddressIssuer));\n\n        case 7:\n          return _context9.abrupt(\"return\", identity);\n\n        case 8:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, _marked8);\n}\nexport function resolveEnsNameToText(ensName) {\n  var invalidEnsError, getTextResult;\n  return _regeneratorRuntime.wrap(function resolveEnsNameToText$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          trace(\"resolving \", ensName);\n\n          if (isApprovedENSDomain(ensName)) {\n            _context10.next = 5;\n            break;\n          }\n\n          invalidEnsError = new Error(\"Issuer identity cannot be verified: \".concat(ensName));\n          error(invalidEnsError);\n          throw invalidEnsError;\n\n        case 5:\n          _context10.next = 7;\n          return call(getText, ensName, \"issuerName\");\n\n        case 7:\n          getTextResult = _context10.sent;\n          trace(\"Got texts records for \".concat(ensName), getTextResult);\n          return _context10.abrupt(\"return\", getTextResult);\n\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, _marked9);\n}\nexport function verifyCertificateDnsIssuer(_ref6) {\n  var issuer, location, dnsRecords, verificationStatus, documentStore;\n  return _regeneratorRuntime.wrap(function verifyCertificateDnsIssuer$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          issuer = _ref6.issuer;\n          location = get(issuer, \"identityProof.location\");\n\n          if (location) {\n            _context11.next = 4;\n            break;\n          }\n\n          return _context11.abrupt(\"return\", false);\n\n        case 4:\n          _context11.next = 6;\n          return call(getDocumentStoreRecords, location);\n\n        case 6:\n          dnsRecords = _context11.sent;\n          trace(\"DNS records: \".concat(_JSON$stringify(dnsRecords))); // dnsRecords: [{addr: \"0xabc\", netId: 3}]\n\n          verificationStatus = false;\n          documentStore = getDocumentStore(issuer);\n\n          if (dnsRecords && dnsRecords.length > 0) {\n            verificationStatus = dnsRecords.find(function (dns) {\n              return dns.addr === documentStore && dns.netId === (IS_MAINNET ? \"1\" : \"3\");\n            });\n          }\n\n          trace(\"DNS Verification Status: \".concat(_JSON$stringify(verificationStatus)));\n          return _context11.abrupt(\"return\", verificationStatus ? location : false);\n\n        case 13:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, _marked10);\n}\nexport function verifyCertificateRegistryIssuer(_ref7) {\n  var issuer, contractStoreAddresses, isValidEthereumAddress, issuerIdentitiesFromRegistry;\n  return _regeneratorRuntime.wrap(function verifyCertificateRegistryIssuer$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          issuer = _ref7.issuer;\n          _context12.prev = 1;\n          contractStoreAddresses = getDocumentStore(issuer);\n          trace(\"Attempting to verify certificate issuers: \".concat(contractStoreAddresses));\n          isValidEthereumAddress = isEthereumAddress(contractStoreAddresses);\n\n          if (isValidEthereumAddress) {\n            _context12.next = 7;\n            break;\n          }\n\n          throw new Error(\"\".concat(contractStoreAddresses, \" is not a valid Ethereum Address\"));\n\n        case 7:\n          trace(\"isValidEthereumAddress\", contractStoreAddresses);\n          _context12.next = 10;\n          return call(lookupAddressOnRegistry, contractStoreAddresses);\n\n        case 10:\n          issuerIdentitiesFromRegistry = _context12.sent;\n          trace(\"Resolved ethereum address \".concat(contractStoreAddresses, \" to \").concat(issuerIdentitiesFromRegistry));\n          return _context12.abrupt(\"return\", get(issuerIdentitiesFromRegistry, \"name\") || false);\n\n        case 15:\n          _context12.prev = 15;\n          _context12.t0 = _context12[\"catch\"](1);\n          return _context12.abrupt(\"return\", false);\n\n        case 18:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, _marked11, null, [[1, 15]]);\n}\n\nfunction throwIfAnyIdentityIsNotVerified(verificationStatuses) {\n  if (verificationStatuses.length === 0) throw new Error(\"No issuers found in the document\");\n  var invalidIdentities = verificationStatuses.filter(function (status) {\n    return !status.registry && !status.dns;\n  });\n\n  if (invalidIdentities.length > 0) {\n    var invalidStoreAddresses = invalidIdentities.map(function (identity) {\n      return identity.documentStore;\n    });\n    throw new Error(\"Issuer identity cannot be verified: \".concat(invalidStoreAddresses.join(\", \")));\n  }\n}\n\nexport function getDetailedIssuerStatus(_ref8) {\n  var issuer, verificationStatus;\n  return _regeneratorRuntime.wrap(function getDetailedIssuerStatus$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          issuer = _ref8.issuer;\n          verificationStatus = {\n            documentStore: getDocumentStore(issuer),\n            registry: null,\n            dns: null\n          };\n          _context13.next = 4;\n          return call(verifyCertificateRegistryIssuer, {\n            issuer: issuer\n          });\n\n        case 4:\n          verificationStatus.registry = _context13.sent;\n\n          if (!(get(issuer, \"identityProof.type\") === \"DNS-TXT\")) {\n            _context13.next = 9;\n            break;\n          }\n\n          _context13.next = 8;\n          return call(verifyCertificateDnsIssuer, {\n            issuer: issuer\n          });\n\n        case 8:\n          verificationStatus.dns = _context13.sent;\n\n        case 9:\n          trace(\"issuer status: \".concat(_JSON$stringify(verificationStatus)));\n          return _context13.abrupt(\"return\", verificationStatus);\n\n        case 11:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, _marked12);\n}\nexport function verifyCertificateIssuer(_ref9) {\n  var certificate, data, issuers, verificationStatuses;\n  return _regeneratorRuntime.wrap(function verifyCertificateIssuer$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          certificate = _ref9.certificate;\n          _context14.prev = 1;\n          data = getData(certificate);\n          issuers = get(data, \"issuers\", []); // verificationStatuses: [{dns: \"abc.com\", registry:\"Govtech\", documentStore: \"0xabc\"}]\n\n          _context14.next = 6;\n          return all(issuers.map(function (issuer) {\n            return call(getDetailedIssuerStatus, {\n              issuer: issuer\n            });\n          }));\n\n        case 6:\n          verificationStatuses = _context14.sent;\n          // If any identity is not verified, this should return false\n          throwIfAnyIdentityIsNotVerified(verificationStatuses);\n          _context14.next = 10;\n          return put(verifyingCertificateIssuerSuccess({\n            issuerIdentities: verificationStatuses\n          }));\n\n        case 10:\n          return _context14.abrupt(\"return\", true);\n\n        case 13:\n          _context14.prev = 13;\n          _context14.t0 = _context14[\"catch\"](1);\n          error(_context14.t0);\n          _context14.next = 18;\n          return put(verifyingCertificateIssuerFailure({\n            error: _context14.t0.message\n          }));\n\n        case 18:\n          return _context14.abrupt(\"return\", false);\n\n        case 19:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, _marked13, null, [[1, 13]]);\n}\nexport function verifyCertificate(_ref10) {\n  var payload, certificateStores, args, verificationStatuses, verified;\n  return _regeneratorRuntime.wrap(function verifyCertificate$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          payload = _ref10.payload;\n          _context15.next = 3;\n          return put({\n            type: types.VERIFYING_CERTIFICATE\n          });\n\n        case 3:\n          _context15.next = 5;\n          return call(loadCertificateContracts, {\n            payload: payload\n          });\n\n        case 5:\n          certificateStores = _context15.sent;\n          args = {\n            certificateStores: certificateStores,\n            certificate: payload\n          };\n          _context15.next = 9;\n          return all({\n            certificateIssued: call(verifyCertificateIssued, args),\n            certificateHashValid: call(verifyCertificateHash, args),\n            certificateNotRevoked: call(verifyCertificateNotRevoked, args),\n            certificateIssuerRecognised: call(verifyCertificateIssuer, args),\n            certificateStoreValid: call(verifyCertificateStore, args)\n          });\n\n        case 9:\n          verificationStatuses = _context15.sent;\n          trace(verificationStatuses);\n          verified = verificationStatuses.certificateIssued && verificationStatuses.certificateHashValid && verificationStatuses.certificateNotRevoked && verificationStatuses.certificateIssuerRecognised && verificationStatuses.certificateStoreValid;\n\n          if (verified) {\n            Router.push(\"/viewer\");\n          }\n\n        case 13:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, _marked14);\n}\nexport function sendCertificate(_ref11) {\n  var payload, certificate, email, captcha, success;\n  return _regeneratorRuntime.wrap(function sendCertificate$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          payload = _ref11.payload;\n          _context16.prev = 1;\n          _context16.next = 4;\n          return select(getCertificate);\n\n        case 4:\n          certificate = _context16.sent;\n          email = payload.email, captcha = payload.captcha;\n          _context16.next = 8;\n          return sendEmail({\n            certificate: certificate,\n            email: email,\n            captcha: captcha\n          });\n\n        case 8:\n          success = _context16.sent;\n\n          if (success) {\n            _context16.next = 11;\n            break;\n          }\n\n          throw new Error(\"Fail to send certificate\");\n\n        case 11:\n          _context16.next = 13;\n          return put({\n            type: types.SENDING_CERTIFICATE_SUCCESS\n          });\n\n        case 13:\n          _context16.next = 19;\n          break;\n\n        case 15:\n          _context16.prev = 15;\n          _context16.t0 = _context16[\"catch\"](1);\n          _context16.next = 19;\n          return put({\n            type: types.SENDING_CERTIFICATE_FAILURE,\n            payload: _context16.t0.message\n          });\n\n        case 19:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, _marked15, null, [[1, 15]]);\n}\nexport function networkReset() {\n  return _regeneratorRuntime.wrap(function networkReset$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _context17.next = 2;\n          return put({\n            type: types.NETWORK_RESET\n          });\n\n        case 2:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, _marked16);\n}\nexport function getAnalyticsDetails() {\n  var rawCertificate, certificate, storeAddresses, id;\n  return _regeneratorRuntime.wrap(function getAnalyticsDetails$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          _context18.prev = 0;\n          _context18.next = 3;\n          return select(getCertificate);\n\n        case 3:\n          rawCertificate = _context18.sent;\n          certificate = getData(rawCertificate);\n          storeAddresses = getDocumentIssuerStores(certificate);\n          id = get(certificate, \"id\");\n          return _context18.abrupt(\"return\", {\n            storeAddresses: storeAddresses,\n            id: id\n          });\n\n        case 10:\n          _context18.prev = 10;\n          _context18.t0 = _context18[\"catch\"](0);\n          return _context18.abrupt(\"return\", {});\n\n        case 13:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, _marked17, null, [[0, 10]]);\n}\nexport function triggerAnalytics(errorCode) {\n  var _ref12, storeAddresses, id;\n\n  return _regeneratorRuntime.wrap(function triggerAnalytics$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          _context19.next = 2;\n          return call(getAnalyticsDetails);\n\n        case 2:\n          _ref12 = _context19.sent;\n          storeAddresses = _ref12.storeAddresses;\n          id = _ref12.id;\n\n          if (storeAddresses && id) {\n            analyticsEvent(window, {\n              category: \"CERTIFICATE_ERROR\",\n              action: storeAddresses,\n              label: id,\n              value: errorCode\n            });\n          }\n\n        case 6:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, _marked18);\n}\nexport function analyticsIssuerFail() {\n  return _regeneratorRuntime.wrap(function analyticsIssuerFail$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _context20.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.ISSUER_IDENTITY);\n\n        case 2:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, _marked19);\n}\nexport function analyticsHashFail() {\n  return _regeneratorRuntime.wrap(function analyticsHashFail$(_context21) {\n    while (1) {\n      switch (_context21.prev = _context21.next) {\n        case 0:\n          _context21.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_HASH);\n\n        case 2:\n        case \"end\":\n          return _context21.stop();\n      }\n    }\n  }, _marked20);\n}\nexport function analyticsIssuedFail() {\n  return _regeneratorRuntime.wrap(function analyticsIssuedFail$(_context22) {\n    while (1) {\n      switch (_context22.prev = _context22.next) {\n        case 0:\n          _context22.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.UNISSUED_CERTIFICATE);\n\n        case 2:\n        case \"end\":\n          return _context22.stop();\n      }\n    }\n  }, _marked21);\n}\nexport function analyticsRevocationFail() {\n  return _regeneratorRuntime.wrap(function analyticsRevocationFail$(_context23) {\n    while (1) {\n      switch (_context23.prev = _context23.next) {\n        case 0:\n          _context23.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.REVOKED_CERTIFICATE);\n\n        case 2:\n        case \"end\":\n          return _context23.stop();\n      }\n    }\n  }, _marked22);\n}\nexport function analyticsStoreFail() {\n  return _regeneratorRuntime.wrap(function analyticsStoreFail$(_context24) {\n    while (1) {\n      switch (_context24.prev = _context24.next) {\n        case 0:\n          _context24.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_STORE);\n\n        case 2:\n        case \"end\":\n          return _context24.stop();\n      }\n    }\n  }, _marked23);\n}\nexport default [takeEvery(types.UPDATE_CERTIFICATE, verifyCertificate), takeEvery(types.SENDING_CERTIFICATE, sendCertificate), takeEvery(applicationTypes.UPDATE_WEB3, networkReset), takeEvery(types.VERIFYING_CERTIFICATE_ISSUER_FAILURE, analyticsIssuerFail), takeEvery(types.VERIFYING_CERTIFICATE_REVOCATION_FAILURE, analyticsRevocationFail), takeEvery(types.VERIFYING_CERTIFICATE_ISSUED_FAILURE, analyticsIssuedFail), takeEvery(types.VERIFYING_CERTIFICATE_HASH_FAILURE, analyticsHashFail), takeEvery(types.VERIFYING_CERTIFICATE_STORE_FAILURE, analyticsStoreFail)];","map":{"version":3,"sources":["/home/ajl/development/ssi/academic-creds/convergence-credentials.github.io/src/sagas/certificate.js"],"names":["loadCertificateContracts","isValidENSDomain","isValidSmartContract","verifyCertificateStore","verifyCertificateHash","verifyCertificateIssued","verifyCertificateNotRevoked","lookupAddressOnRegistry","resolveEnsNameToText","verifyCertificateDnsIssuer","verifyCertificateRegistryIssuer","getDetailedIssuerStatus","verifyCertificateIssuer","verifyCertificate","sendCertificate","networkReset","getAnalyticsDetails","triggerAnalytics","analyticsIssuerFail","analyticsHashFail","analyticsIssuedFail","analyticsRevocationFail","analyticsStoreFail","some","get","partition","compact","mapKeys","put","all","call","select","takeEvery","getData","verifySignature","isValidAddress","isEthereumAddress","Router","getDocumentStoreRecords","getLogger","types","verifyingCertificateIssuerSuccess","verifyingCertificateIssuerFailure","verifyingCertificateRevocationSuccess","verifyingCertificateRevocationFailure","verifyingCertificateIssuedSuccess","verifyingCertificateIssuedFailure","verifyingCertificateHashSuccess","verifyingCertificateHashFailure","verifyingCertificateStoreSuccess","verifyingCertificateStoreFailure","getCertificate","applicationTypes","DocumentStoreDefinition","fetchIssuers","combinedHash","ensResolveAddress","getText","sendEmail","analyticsEvent","getDocumentStore","getDocumentIssuerStores","getSelectedWeb3","IS_MAINNET","trace","error","ANALYTICS_VERIFICATION_ERROR_CODE","ISSUER_IDENTITY","CERTIFICATE_HASH","UNISSUED_CERTIFICATE","REVOKED_CERTIFICATE","CERTIFICATE_STORE","payload","data","unresolvedContractStoreAddresses","map","issuer","web3","unresolvedAddress","contractStoreAddresses","abi","contracts","address","eth","Contract","type","LOADING_STORE_SUCCESS","LOADING_STORE_FAILURE","storeAddress","Error","ens","getAddress","ensToAddress","supportedContractHashes","getCode","onChainByteCode","hashOfOnChainByteCode","utils","keccak256","includes","certificate","ethereumAddressIssuers","unresolvedEnsNames","unresolvedEnsName","resolvedEnsNames","combinedStoreAddresses","concat","message","verified","hashError","certificateStores","merkleRoot","store","methods","isIssued","issuedStatuses","length","reduce","prev","curr","getIntermediateHashes","targetHash","proof","intermediateHashes","accumulator","currentValue","combined","toString","push","i","hash","isRevoked","revokedStatus","isApprovedENSDomain","issuerAddress","approvedENSDomains","domainMask","test","toLowerCase","ethereumAddressIssuer","registeredIssuers","issuersNormalised","_","k","toUpperCase","identity","ensName","invalidEnsError","getTextResult","location","dnsRecords","verificationStatus","documentStore","find","dns","addr","netId","isValidEthereumAddress","issuerIdentitiesFromRegistry","throwIfAnyIdentityIsNotVerified","verificationStatuses","invalidIdentities","filter","status","registry","invalidStoreAddresses","join","issuers","issuerIdentities","VERIFYING_CERTIFICATE","args","certificateIssued","certificateHashValid","certificateNotRevoked","certificateIssuerRecognised","certificateStoreValid","email","captcha","success","SENDING_CERTIFICATE_SUCCESS","SENDING_CERTIFICATE_FAILURE","NETWORK_RESET","rawCertificate","storeAddresses","id","errorCode","window","category","action","label","value","UPDATE_CERTIFICATE","SENDING_CERTIFICATE","UPDATE_WEB3","VERIFYING_CERTIFICATE_ISSUER_FAILURE","VERIFYING_CERTIFICATE_REVOCATION_FAILURE","VERIFYING_CERTIFICATE_ISSUED_FAILURE","VERIFYING_CERTIFICATE_HASH_FAILURE","VERIFYING_CERTIFICATE_STORE_FAILURE"],"mappings":"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","sourcesContent":["import { some, get, partition, compact, mapKeys } from \"lodash\";\nimport { put, all, call, select, takeEvery } from \"redux-saga/effects\";\nimport { getData, verifySignature } from \"@govtechsg/open-attestation\";\nimport { isValidAddress as isEthereumAddress } from \"ethereumjs-util\";\nimport Router from \"next/router\";\nimport { getDocumentStoreRecords } from \"@govtechsg/dnsprove\";\nimport { getLogger } from \"../utils/logger\";\nimport {\n  types,\n  verifyingCertificateIssuerSuccess,\n  verifyingCertificateIssuerFailure,\n  verifyingCertificateRevocationSuccess,\n  verifyingCertificateRevocationFailure,\n  verifyingCertificateIssuedSuccess,\n  verifyingCertificateIssuedFailure,\n  verifyingCertificateHashSuccess,\n  verifyingCertificateHashFailure,\n  verifyingCertificateStoreSuccess,\n  verifyingCertificateStoreFailure,\n  getCertificate\n} from \"../reducers/certificate\";\nimport { types as applicationTypes } from \"../reducers/application\";\nimport DocumentStoreDefinition from \"../services/contracts/DocumentStore.json\";\nimport fetchIssuers from \"../services/issuers\";\nimport { combinedHash } from \"../utils\";\nimport { ensResolveAddress, getText } from \"../services/ens\";\nimport sendEmail from \"../services/email\";\nimport { analyticsEvent } from \"../components/Analytics\";\nimport {\n  getDocumentStore,\n  getDocumentIssuerStores\n} from \"../utils/certificate\";\nimport { getSelectedWeb3 } from \"./application\";\nimport { IS_MAINNET } from \"../config\";\n\nconst { trace, error } = getLogger(\"saga:certificate\");\n\nconst ANALYTICS_VERIFICATION_ERROR_CODE = {\n  ISSUER_IDENTITY: 0,\n  CERTIFICATE_HASH: 1,\n  UNISSUED_CERTIFICATE: 2,\n  REVOKED_CERTIFICATE: 3,\n  CERTIFICATE_STORE: 4\n};\n\nexport function* loadCertificateContracts({ payload }) {\n  try {\n    const data = getData(payload);\n    trace(`Loading certificate: ${data}`);\n    const unresolvedContractStoreAddresses = get(data, \"issuers\", []).map(\n      issuer => getDocumentStore(issuer)\n    );\n    const web3 = yield getSelectedWeb3();\n    const contractStoreAddresses = yield all(\n      unresolvedContractStoreAddresses.map(unresolvedAddress =>\n        call(ensResolveAddress, unresolvedAddress)\n      )\n    );\n    trace(`Resolved certificate's store addresses, ${contractStoreAddresses}`);\n\n    const { abi } = DocumentStoreDefinition;\n\n    const contracts = contractStoreAddresses.map(\n      address => new web3.eth.Contract(abi, address)\n    );\n\n    yield put({\n      type: types.LOADING_STORE_SUCCESS\n    });\n    return contracts;\n  } catch (e) {\n    yield put({\n      type: types.LOADING_STORE_FAILURE,\n      payload: e\n    });\n    return null;\n  }\n}\n\nexport function* isValidENSDomain(storeAddress) {\n  trace(`Checking if ${storeAddress} is a valid ENS Domain`);\n  if (storeAddress == null) {\n    throw new Error(\"No address in certificate\");\n  }\n  const web3 = yield getSelectedWeb3();\n  const ensToAddress = yield web3.eth.ens.getAddress(storeAddress);\n  if (ensToAddress === null) {\n    throw new Error(\"Invalid ENS\");\n  }\n  return ensToAddress;\n}\n\nexport function* isValidSmartContract(storeAddress) {\n  const web3 = yield getSelectedWeb3();\n  const supportedContractHashes = [\n    \"0x7135575eac76f1817c27b06c452bdc2b7e1b13240797415684e227def063a127\"\n  ];\n  const onChainByteCode = yield web3.eth.getCode(storeAddress);\n  const hashOfOnChainByteCode = web3.utils.keccak256(onChainByteCode);\n  if (!supportedContractHashes.includes(hashOfOnChainByteCode)) {\n    throw new Error(\"Invalid smart contract: \"`${storeAddress}`);\n  }\n  return true;\n}\n\nexport function* verifyCertificateStore({ certificate }) {\n  try {\n    const data = getData(certificate);\n\n    const contractStoreAddresses = get(data, \"issuers\", []).map(issuer =>\n      getDocumentStore(issuer)\n    );\n    trace(`Attempting to verify certificate store: ${contractStoreAddresses}`);\n\n    const [ethereumAddressIssuers, unresolvedEnsNames] = partition(\n      contractStoreAddresses,\n      isEthereumAddress\n    );\n    trace(\"ethereumAddressIssuers\", ethereumAddressIssuers);\n    trace(\"unresolvedEnsNames\", unresolvedEnsNames);\n\n    const resolvedEnsNames = yield unresolvedEnsNames.map(unresolvedEnsName =>\n      call(isValidENSDomain, unresolvedEnsName)\n    );\n\n    // Concat the 2 arrays\n    const combinedStoreAddresses = compact(\n      ethereumAddressIssuers.concat(resolvedEnsNames)\n    );\n\n    // Checks if issuing institution has a valid smart contract with OpenCerts\n    yield combinedStoreAddresses.map(address => isValidSmartContract(address));\n    yield put(verifyingCertificateStoreSuccess());\n    return combinedStoreAddresses;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateStoreFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nexport function* verifyCertificateHash({ certificate }) {\n  const verified = verifySignature(certificate);\n\n  if (verified) {\n    yield put(verifyingCertificateHashSuccess());\n\n    return true;\n  }\n  const hashError = new Error(\"Certificate data does not match target hash\");\n  error(hashError);\n  yield put(\n    verifyingCertificateHashFailure({\n      error: hashError.message\n    })\n  );\n  return false;\n}\n\nexport function* verifyCertificateIssued({ certificate, certificateStores }) {\n  try {\n    const merkleRoot = `0x${get(certificate, \"signature.merkleRoot\", \"\")}`;\n\n    // Checks if certificate has been issued on ALL store\n    const issuedStatuses = yield all(\n      certificateStores.map(store => store.methods.isIssued(merkleRoot).call())\n    );\n    if (issuedStatuses.length === 0) throw new Error(\"Invalid file\");\n    const isIssued = issuedStatuses.reduce((prev, curr) => prev && curr, true);\n    if (!isIssued) throw new Error(\"Certificate has not been issued\");\n    yield put(verifyingCertificateIssuedSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateIssuedFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nexport const getIntermediateHashes = (targetHash, proof = []) => {\n  // Returns hash of all intermediate hashes from targetHash to merkleRoot\n  const intermediateHashes = [`0x${targetHash}`];\n\n  proof.reduce((accumulator, currentValue) => {\n    const combined = combinedHash(accumulator, currentValue).toString(\"hex\");\n    intermediateHashes.push(`0x${combined}`);\n    return combined;\n  }, targetHash);\n\n  return intermediateHashes;\n};\n\nexport function* verifyCertificateNotRevoked({\n  certificate,\n  certificateStores\n}) {\n  try {\n    const targetHash = get(certificate, \"signature.targetHash\", null);\n    const proof = get(certificate, \"signature.proof\", null);\n\n    // Checks if certificate and path towards merkle root has been revoked\n    const intermediateHashes = getIntermediateHashes(targetHash, proof);\n\n    for (let i = 0; i < intermediateHashes.length; i += 1) {\n      const hash = intermediateHashes[i];\n\n      // Check if certificate is revoked on ALL store\n      const revokedStatus = yield all(\n        certificateStores.map(store => store.methods.isRevoked(hash).call())\n      );\n      const isRevoked = revokedStatus.reduce(\n        (prev, curr) => prev || curr,\n        false\n      );\n      if (isRevoked)\n        throw new Error(`Certificate has been revoked, revoked hash: ${hash}`);\n    }\n\n    yield put(verifyingCertificateRevocationSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateRevocationFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nfunction isApprovedENSDomain(issuerAddress) {\n  trace(`Checking if ${issuerAddress} is opencerts TLD`);\n  const approvedENSDomains = [/(opencerts.eth)$/];\n  return some(\n    approvedENSDomains.map(domainMask =>\n      domainMask.test(issuerAddress.toLowerCase())\n    )\n  );\n}\n\nexport function* lookupAddressOnRegistry(ethereumAddressIssuer) {\n  const registeredIssuers = yield fetchIssuers();\n  const issuersNormalised = mapKeys(registeredIssuers, (_, k) =>\n    k.toUpperCase()\n  );\n\n  const identity = issuersNormalised[ethereumAddressIssuer.toUpperCase()];\n  if (!identity) {\n    throw new Error(\n      `Issuer identity cannot be verified: ${ethereumAddressIssuer}`\n    );\n  }\n  return identity;\n}\n\nexport function* resolveEnsNameToText(ensName) {\n  trace(\"resolving \", ensName);\n  if (!isApprovedENSDomain(ensName)) {\n    const invalidEnsError = new Error(\n      `Issuer identity cannot be verified: ${ensName}`\n    );\n    error(invalidEnsError);\n    throw invalidEnsError;\n  }\n\n  const getTextResult = yield call(getText, ensName, \"issuerName\");\n  trace(`Got texts records for ${ensName}`, getTextResult);\n  return getTextResult;\n}\n\nexport function* verifyCertificateDnsIssuer({ issuer }) {\n  const location = get(issuer, \"identityProof.location\");\n\n  if (!location) return false;\n\n  const dnsRecords = yield call(getDocumentStoreRecords, location);\n\n  trace(`DNS records: ${JSON.stringify(dnsRecords)}`); // dnsRecords: [{addr: \"0xabc\", netId: 3}]\n  let verificationStatus = false;\n  const documentStore = getDocumentStore(issuer);\n  if (dnsRecords && dnsRecords.length > 0) {\n    verificationStatus = dnsRecords.find(\n      dns =>\n        dns.addr === documentStore && dns.netId === (IS_MAINNET ? \"1\" : \"3\")\n    );\n  }\n  trace(`DNS Verification Status: ${JSON.stringify(verificationStatus)}`);\n  return verificationStatus ? location : false;\n}\n\nexport function* verifyCertificateRegistryIssuer({ issuer }) {\n  try {\n    const contractStoreAddresses = getDocumentStore(issuer);\n    trace(\n      `Attempting to verify certificate issuers: ${contractStoreAddresses}`\n    );\n    const isValidEthereumAddress = isEthereumAddress(contractStoreAddresses);\n\n    if (!isValidEthereumAddress) {\n      throw new Error(\n        `${contractStoreAddresses} is not a valid Ethereum Address`\n      );\n    }\n\n    trace(\"isValidEthereumAddress\", contractStoreAddresses);\n\n    const issuerIdentitiesFromRegistry = yield call(\n      lookupAddressOnRegistry,\n      contractStoreAddresses\n    );\n    trace(\n      `Resolved ethereum address ${contractStoreAddresses} to ${issuerIdentitiesFromRegistry}`\n    );\n    return get(issuerIdentitiesFromRegistry, \"name\") || false;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction throwIfAnyIdentityIsNotVerified(verificationStatuses) {\n  if (verificationStatuses.length === 0)\n    throw new Error(\"No issuers found in the document\");\n  const invalidIdentities = verificationStatuses.filter(\n    status => !status.registry && !status.dns\n  );\n  if (invalidIdentities.length > 0) {\n    const invalidStoreAddresses = invalidIdentities.map(\n      identity => identity.documentStore\n    );\n    throw new Error(\n      `Issuer identity cannot be verified: ${invalidStoreAddresses.join(\", \")}`\n    );\n  }\n}\n\nexport function* getDetailedIssuerStatus({ issuer }) {\n  const verificationStatus = {\n    documentStore: getDocumentStore(issuer),\n    registry: null,\n    dns: null\n  };\n\n  verificationStatus.registry = yield call(verifyCertificateRegistryIssuer, {\n    issuer\n  });\n\n  if (get(issuer, \"identityProof.type\") === \"DNS-TXT\") {\n    verificationStatus.dns = yield call(verifyCertificateDnsIssuer, {\n      issuer\n    });\n  }\n  trace(`issuer status: ${JSON.stringify(verificationStatus)}`);\n  return verificationStatus;\n}\n\nexport function* verifyCertificateIssuer({ certificate }) {\n  try {\n    const data = getData(certificate);\n    const issuers = get(data, \"issuers\", []);\n    // verificationStatuses: [{dns: \"abc.com\", registry:\"Govtech\", documentStore: \"0xabc\"}]\n    const verificationStatuses = yield all(\n      issuers.map(issuer => call(getDetailedIssuerStatus, { issuer }))\n    );\n\n    // If any identity is not verified, this should return false\n    throwIfAnyIdentityIsNotVerified(verificationStatuses);\n\n    yield put(\n      verifyingCertificateIssuerSuccess({\n        issuerIdentities: verificationStatuses\n      })\n    );\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateIssuerFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nexport function* verifyCertificate({ payload }) {\n  yield put({\n    type: types.VERIFYING_CERTIFICATE\n  });\n  const certificateStores = yield call(loadCertificateContracts, { payload });\n  const args = { certificateStores, certificate: payload };\n\n  const verificationStatuses = yield all({\n    certificateIssued: call(verifyCertificateIssued, args),\n    certificateHashValid: call(verifyCertificateHash, args),\n    certificateNotRevoked: call(verifyCertificateNotRevoked, args),\n    certificateIssuerRecognised: call(verifyCertificateIssuer, args),\n    certificateStoreValid: call(verifyCertificateStore, args)\n  });\n  trace(verificationStatuses);\n  const verified =\n    verificationStatuses.certificateIssued &&\n    verificationStatuses.certificateHashValid &&\n    verificationStatuses.certificateNotRevoked &&\n    verificationStatuses.certificateIssuerRecognised &&\n    verificationStatuses.certificateStoreValid;\n  if (verified) {\n    Router.push(\"/viewer\");\n  }\n}\n\nexport function* sendCertificate({ payload }) {\n  try {\n    const certificate = yield select(getCertificate);\n    const { email, captcha } = payload;\n    const success = yield sendEmail({\n      certificate,\n      email,\n      captcha\n    });\n\n    if (!success) {\n      throw new Error(\"Fail to send certificate\");\n    }\n\n    yield put({\n      type: types.SENDING_CERTIFICATE_SUCCESS\n    });\n  } catch (e) {\n    yield put({\n      type: types.SENDING_CERTIFICATE_FAILURE,\n      payload: e.message\n    });\n  }\n}\n\nexport function* networkReset() {\n  yield put({\n    type: types.NETWORK_RESET\n  });\n}\n\nexport function* getAnalyticsDetails() {\n  try {\n    const rawCertificate = yield select(getCertificate);\n    const certificate = getData(rawCertificate);\n\n    const storeAddresses = getDocumentIssuerStores(certificate);\n    const id = get(certificate, \"id\");\n    return { storeAddresses, id };\n  } catch (e) {\n    return {};\n  }\n}\n\nexport function* triggerAnalytics(errorCode) {\n  const { storeAddresses, id } = yield call(getAnalyticsDetails);\n  if (storeAddresses && id) {\n    analyticsEvent(window, {\n      category: \"CERTIFICATE_ERROR\",\n      action: storeAddresses,\n      label: id,\n      value: errorCode\n    });\n  }\n}\n\nexport function* analyticsIssuerFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.ISSUER_IDENTITY\n  );\n}\n\nexport function* analyticsHashFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_HASH\n  );\n}\n\nexport function* analyticsIssuedFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.UNISSUED_CERTIFICATE\n  );\n}\n\nexport function* analyticsRevocationFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.REVOKED_CERTIFICATE\n  );\n}\n\nexport function* analyticsStoreFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_STORE\n  );\n}\n\nexport default [\n  takeEvery(types.UPDATE_CERTIFICATE, verifyCertificate),\n  takeEvery(types.SENDING_CERTIFICATE, sendCertificate),\n  takeEvery(applicationTypes.UPDATE_WEB3, networkReset),\n\n  takeEvery(types.VERIFYING_CERTIFICATE_ISSUER_FAILURE, analyticsIssuerFail),\n  takeEvery(\n    types.VERIFYING_CERTIFICATE_REVOCATION_FAILURE,\n    analyticsRevocationFail\n  ),\n  takeEvery(types.VERIFYING_CERTIFICATE_ISSUED_FAILURE, analyticsIssuedFail),\n  takeEvery(types.VERIFYING_CERTIFICATE_HASH_FAILURE, analyticsHashFail),\n  takeEvery(types.VERIFYING_CERTIFICATE_STORE_FAILURE, analyticsStoreFail)\n];\n"]},"metadata":{},"sourceType":"module"}