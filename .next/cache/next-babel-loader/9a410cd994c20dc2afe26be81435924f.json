{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport { some, get, partition, compact, mapKeys } from \"lodash\";\nimport { put, all, call, select, takeEvery } from \"redux-saga/effects\";\nimport { getData, verifySignature } from \"@govtechsg/open-attestation\";\nimport { isValidAddress as isEthereumAddress } from \"ethereumjs-util\";\nimport Router from \"next/router\";\nimport { getDocumentStoreRecords } from \"@govtechsg/dnsprove\";\nimport { getLogger } from \"../utils/logger\";\nimport { types, verifyingCertificateIssuerSuccess, verifyingCertificateIssuerFailure, verifyingCertificateRevocationSuccess, verifyingCertificateRevocationFailure, verifyingCertificateIssuedSuccess, verifyingCertificateIssuedFailure, verifyingCertificateHashSuccess, verifyingCertificateHashFailure, verifyingCertificateStoreSuccess, verifyingCertificateStoreFailure, getCertificate } from \"../reducers/certificate\";\nimport { types as applicationTypes } from \"../reducers/application\";\nimport DocumentStoreDefinition from \"../services/contracts/DocumentStore.json\";\nimport fetchIssuers from \"../services/issuers\";\nimport { combinedHash } from \"../utils\";\nimport { ensResolveAddress, getText } from \"../services/ens\";\nimport sendEmail from \"../services/email\";\nimport { analyticsEvent } from \"../components/Analytics\";\nimport { getDocumentStore, getDocumentIssuerStores } from \"../utils/certificate\";\nimport { getSelectedWeb3 } from \"./application\";\nimport { IS_MAINNET } from \"../config\";\nconst {\n  trace,\n  error\n} = getLogger(\"saga:certificate\");\nconst ANALYTICS_VERIFICATION_ERROR_CODE = {\n  ISSUER_IDENTITY: 0,\n  CERTIFICATE_HASH: 1,\n  UNISSUED_CERTIFICATE: 2,\n  REVOKED_CERTIFICATE: 3,\n  CERTIFICATE_STORE: 4\n};\nexport function* loadCertificateContracts({\n  payload\n}) {\n  try {\n    const data = getData(payload);\n    trace(`Loading certificate: ${data}`);\n    const unresolvedContractStoreAddresses = get(data, \"issuers\", []).map(issuer => getDocumentStore(issuer));\n    const web3 = yield getSelectedWeb3();\n    const contractStoreAddresses = yield all(unresolvedContractStoreAddresses.map(unresolvedAddress => call(ensResolveAddress, unresolvedAddress)));\n    trace(`Resolved certificate's store addresses, ${contractStoreAddresses}`);\n    const {\n      abi\n    } = DocumentStoreDefinition;\n    const contracts = contractStoreAddresses.map(address => new web3.eth.Contract(abi, address));\n    yield put({\n      type: types.LOADING_STORE_SUCCESS\n    });\n    return contracts;\n  } catch (e) {\n    yield put({\n      type: types.LOADING_STORE_FAILURE,\n      payload: e\n    });\n    return null;\n  }\n}\nexport function* isValidENSDomain(storeAddress) {\n  trace(`Checking if ${storeAddress} is a valid ENS Domain`);\n\n  if (storeAddress == null) {\n    throw new Error(\"No address in certificate\");\n  }\n\n  const web3 = yield getSelectedWeb3();\n  const ensToAddress = yield web3.eth.ens.getAddress(storeAddress);\n\n  if (ensToAddress === null) {\n    throw new Error(\"Invalid ENS\");\n  }\n\n  return ensToAddress;\n}\nexport function* isValidSmartContract(storeAddress) {\n  const web3 = yield getSelectedWeb3();\n  const supportedContractHashes = [\"0x7135575eac76f1817c27b06c452bdc2b7e1b13240797415684e227def063a127\"];\n  const onChainByteCode = yield web3.eth.getCode(storeAddress);\n  const hashOfOnChainByteCode = web3.utils.keccak256(onChainByteCode);\n\n  if (!supportedContractHashes.includes(hashOfOnChainByteCode)) {\n    throw new Error(\"Invalid smart contract: \"`${storeAddress}`);\n  }\n\n  return true;\n}\nexport function* verifyCertificateStore({\n  certificate\n}) {\n  try {\n    const data = getData(certificate);\n    const contractStoreAddresses = get(data, \"issuers\", []).map(issuer => getDocumentStore(issuer));\n    trace(`Attempting to verify certificate store: ${contractStoreAddresses}`);\n    const [ethereumAddressIssuers, unresolvedEnsNames] = partition(contractStoreAddresses, isEthereumAddress);\n    trace(\"ethereumAddressIssuers\", ethereumAddressIssuers);\n    trace(\"unresolvedEnsNames\", unresolvedEnsNames);\n    const resolvedEnsNames = yield unresolvedEnsNames.map(unresolvedEnsName => call(isValidENSDomain, unresolvedEnsName)); // Concat the 2 arrays\n\n    const combinedStoreAddresses = compact(ethereumAddressIssuers.concat(resolvedEnsNames)); // Checks if issuing institution has a valid smart contract with OpenCerts\n\n    yield combinedStoreAddresses.map(address => isValidSmartContract(address));\n    yield put(verifyingCertificateStoreSuccess());\n    return combinedStoreAddresses;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateStoreFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\nexport function* verifyCertificateHash({\n  certificate\n}) {\n  const verified = verifySignature(certificate);\n\n  if (verified) {\n    yield put(verifyingCertificateHashSuccess());\n    return true;\n  }\n\n  const hashError = new Error(\"Certificate data does not match target hash\");\n  error(hashError);\n  yield put(verifyingCertificateHashFailure({\n    error: hashError.message\n  }));\n  return false;\n}\nexport function* verifyCertificateIssued({\n  certificate,\n  certificateStores\n}) {\n  try {\n    const merkleRoot = `0x${get(certificate, \"signature.merkleRoot\", \"\")}`; // Checks if certificate has been issued on ALL store\n\n    const issuedStatuses = yield all(certificateStores.map(store => store.methods.isIssued(merkleRoot).call()));\n    if (issuedStatuses.length === 0) throw new Error(\"Invalid file\");\n    const isIssued = issuedStatuses.reduce((prev, curr) => prev && curr, true);\n    if (!isIssued) throw new Error(\"Certificate has not been issued\");\n    yield put(verifyingCertificateIssuedSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateIssuedFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\nexport const getIntermediateHashes = (targetHash, proof = []) => {\n  // Returns hash of all intermediate hashes from targetHash to merkleRoot\n  const intermediateHashes = [`0x${targetHash}`];\n  proof.reduce((accumulator, currentValue) => {\n    const combined = combinedHash(accumulator, currentValue).toString(\"hex\");\n    intermediateHashes.push(`0x${combined}`);\n    return combined;\n  }, targetHash);\n  return intermediateHashes;\n};\nexport function* verifyCertificateNotRevoked({\n  certificate,\n  certificateStores\n}) {\n  try {\n    const targetHash = get(certificate, \"signature.targetHash\", null);\n    const proof = get(certificate, \"signature.proof\", null); // Checks if certificate and path towards merkle root has been revoked\n\n    const intermediateHashes = getIntermediateHashes(targetHash, proof);\n\n    for (let i = 0; i < intermediateHashes.length; i += 1) {\n      const hash = intermediateHashes[i]; // Check if certificate is revoked on ALL store\n\n      const revokedStatus = yield all(certificateStores.map(store => store.methods.isRevoked(hash).call()));\n      const isRevoked = revokedStatus.reduce((prev, curr) => prev || curr, false);\n      if (isRevoked) throw new Error(`Certificate has been revoked, revoked hash: ${hash}`);\n    }\n\n    yield put(verifyingCertificateRevocationSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateRevocationFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\n\nfunction isApprovedENSDomain(issuerAddress) {\n  trace(`Checking if ${issuerAddress} is opencerts TLD`);\n  const approvedENSDomains = [/(opencerts.eth)$/];\n  return some(approvedENSDomains.map(domainMask => domainMask.test(issuerAddress.toLowerCase())));\n}\n\nexport function* lookupAddressOnRegistry(ethereumAddressIssuer) {\n  const registeredIssuers = yield fetchIssuers();\n  const issuersNormalised = mapKeys(registeredIssuers, (_, k) => k.toUpperCase());\n  const identity = issuersNormalised[ethereumAddressIssuer.toUpperCase()];\n\n  if (!identity) {\n    throw new Error(`Issuer identity cannot be verified: ${ethereumAddressIssuer}`);\n  }\n\n  return identity;\n}\nexport function* resolveEnsNameToText(ensName) {\n  trace(\"resolving \", ensName);\n\n  if (!isApprovedENSDomain(ensName)) {\n    const invalidEnsError = new Error(`Issuer identity cannot be verified: ${ensName}`);\n    error(invalidEnsError);\n    throw invalidEnsError;\n  }\n\n  const getTextResult = yield call(getText, ensName, \"issuerName\");\n  trace(`Got texts records for ${ensName}`, getTextResult);\n  return getTextResult;\n}\nexport function* verifyCertificateDnsIssuer({\n  issuer\n}) {\n  const location = get(issuer, \"identityProof.location\");\n  if (!location) return false;\n  const dnsRecords = yield call(getDocumentStoreRecords, location);\n  trace(`DNS records: ${_JSON$stringify(dnsRecords)}`); // dnsRecords: [{addr: \"0xabc\", netId: 3}]\n\n  let verificationStatus = false;\n  const documentStore = getDocumentStore(issuer);\n\n  if (dnsRecords && dnsRecords.length > 0) {\n    verificationStatus = dnsRecords.find(dns => dns.addr === documentStore && dns.netId === (IS_MAINNET ? \"1\" : \"3\"));\n  }\n\n  trace(`DNS Verification Status: ${_JSON$stringify(verificationStatus)}`);\n  return verificationStatus ? location : false;\n}\nexport function* verifyCertificateRegistryIssuer({\n  issuer\n}) {\n  try {\n    const contractStoreAddresses = getDocumentStore(issuer);\n    trace(`Attempting to verify certificate issuers: ${contractStoreAddresses}`);\n    const isValidEthereumAddress = isEthereumAddress(contractStoreAddresses);\n\n    if (!isValidEthereumAddress) {\n      throw new Error(`${contractStoreAddresses} is not a valid Ethereum Address`);\n    }\n\n    trace(\"isValidEthereumAddress\", contractStoreAddresses);\n    const issuerIdentitiesFromRegistry = yield call(lookupAddressOnRegistry, contractStoreAddresses);\n    trace(`Resolved ethereum address ${contractStoreAddresses} to ${issuerIdentitiesFromRegistry}`);\n    return get(issuerIdentitiesFromRegistry, \"name\") || false;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction throwIfAnyIdentityIsNotVerified(verificationStatuses) {\n  if (verificationStatuses.length === 0) throw new Error(\"No issuers found in the document\");\n  const invalidIdentities = verificationStatuses.filter(status => !status.registry && !status.dns);\n\n  if (invalidIdentities.length > 0) {\n    const invalidStoreAddresses = invalidIdentities.map(identity => identity.documentStore);\n    throw new Error(`Issuer identity cannot be verified: ${invalidStoreAddresses.join(\", \")}`);\n  }\n}\n\nexport function* getDetailedIssuerStatus({\n  issuer\n}) {\n  const verificationStatus = {\n    documentStore: getDocumentStore(issuer),\n    registry: null,\n    dns: null\n  };\n  verificationStatus.registry = yield call(verifyCertificateRegistryIssuer, {\n    issuer\n  });\n\n  if (get(issuer, \"identityProof.type\") === \"DNS-TXT\") {\n    verificationStatus.dns = yield call(verifyCertificateDnsIssuer, {\n      issuer\n    });\n  }\n\n  trace(`issuer status: ${_JSON$stringify(verificationStatus)}`);\n  return verificationStatus;\n}\nexport function* verifyCertificateIssuer({\n  certificate\n}) {\n  try {\n    const data = getData(certificate);\n    const issuers = get(data, \"issuers\", []); // verificationStatuses: [{dns: \"abc.com\", registry:\"Govtech\", documentStore: \"0xabc\"}]\n\n    const verificationStatuses = yield all(issuers.map(issuer => call(getDetailedIssuerStatus, {\n      issuer\n    }))); // If any identity is not verified, this should return false\n\n    throwIfAnyIdentityIsNotVerified(verificationStatuses);\n    yield put(verifyingCertificateIssuerSuccess({\n      issuerIdentities: verificationStatuses\n    }));\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateIssuerFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\nexport function* verifyCertificate({\n  payload\n}) {\n  yield put({\n    type: types.VERIFYING_CERTIFICATE\n  });\n  const certificateStores = yield call(loadCertificateContracts, {\n    payload\n  });\n  const args = {\n    certificateStores,\n    certificate: payload\n  };\n  const verificationStatuses = yield all({\n    certificateIssued: call(verifyCertificateIssued, args),\n    certificateHashValid: call(verifyCertificateHash, args),\n    certificateNotRevoked: call(verifyCertificateNotRevoked, args),\n    certificateIssuerRecognised: call(verifyCertificateIssuer, args),\n    certificateStoreValid: call(verifyCertificateStore, args)\n  });\n  trace(verificationStatuses);\n  const verified = verificationStatuses.certificateIssued && verificationStatuses.certificateHashValid && verificationStatuses.certificateNotRevoked && verificationStatuses.certificateIssuerRecognised && verificationStatuses.certificateStoreValid;\n\n  if (verified) {\n    Router.push(\"/viewer\");\n  }\n}\nexport function* sendCertificate({\n  payload\n}) {\n  try {\n    const certificate = yield select(getCertificate);\n    const {\n      email,\n      captcha\n    } = payload;\n    const success = yield sendEmail({\n      certificate,\n      email,\n      captcha\n    });\n\n    if (!success) {\n      throw new Error(\"Fail to send certificate\");\n    }\n\n    yield put({\n      type: types.SENDING_CERTIFICATE_SUCCESS\n    });\n  } catch (e) {\n    yield put({\n      type: types.SENDING_CERTIFICATE_FAILURE,\n      payload: e.message\n    });\n  }\n}\nexport function* networkReset() {\n  yield put({\n    type: types.NETWORK_RESET\n  });\n}\nexport function* getAnalyticsDetails() {\n  try {\n    const rawCertificate = yield select(getCertificate);\n    const certificate = getData(rawCertificate);\n    const storeAddresses = getDocumentIssuerStores(certificate);\n    const id = get(certificate, \"id\");\n    return {\n      storeAddresses,\n      id\n    };\n  } catch (e) {\n    return {};\n  }\n}\nexport function* triggerAnalytics(errorCode) {\n  const {\n    storeAddresses,\n    id\n  } = yield call(getAnalyticsDetails);\n\n  if (storeAddresses && id) {\n    analyticsEvent(window, {\n      category: \"CERTIFICATE_ERROR\",\n      action: storeAddresses,\n      label: id,\n      value: errorCode\n    });\n  }\n}\nexport function* analyticsIssuerFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.ISSUER_IDENTITY);\n}\nexport function* analyticsHashFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_HASH);\n}\nexport function* analyticsIssuedFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.UNISSUED_CERTIFICATE);\n}\nexport function* analyticsRevocationFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.REVOKED_CERTIFICATE);\n}\nexport function* analyticsStoreFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_STORE);\n}\nexport default [takeEvery(types.UPDATE_CERTIFICATE, verifyCertificate), takeEvery(types.SENDING_CERTIFICATE, sendCertificate), takeEvery(applicationTypes.UPDATE_WEB3, networkReset), takeEvery(types.VERIFYING_CERTIFICATE_ISSUER_FAILURE, analyticsIssuerFail), takeEvery(types.VERIFYING_CERTIFICATE_REVOCATION_FAILURE, analyticsRevocationFail), takeEvery(types.VERIFYING_CERTIFICATE_ISSUED_FAILURE, analyticsIssuedFail), takeEvery(types.VERIFYING_CERTIFICATE_HASH_FAILURE, analyticsHashFail), takeEvery(types.VERIFYING_CERTIFICATE_STORE_FAILURE, analyticsStoreFail)];","map":null,"metadata":{},"sourceType":"module"}