{"ast":null,"code":"import { stripHexPrefix, bufferToHex, keccak256 } from \"ethereumjs-util\";\nimport { reduceRight } from \"lodash\";\nimport ensContractABI from \"./contracts/ensContract.json\";\nimport resolverABI from \"./contracts/resolverContract.json\";\nimport { getWeb3 } from \"../web3\";\nimport { getLogger } from \"../../utils/logger\";\nconst {\n  trace,\n  error\n} = getLogger(\"services:ens\"); // Well-known addresses for ENS registry contracts\n\nconst ensRegistryContractAddress = {\n  1: {\n    registry: \"0x314159265dd8dbb310642f98f50c066173c1259b\"\n  },\n  3: {\n    registry: \"0x112234455c3a32fd11230c42e7bccd4a84e02010\"\n  }\n};\n\nfunction keccak256String(label) {\n  return bufferToHex(keccak256(label));\n}\n\nfunction appendHash(node, label) {\n  return keccak256String(node + stripHexPrefix(keccak256String(label)));\n}\n\nexport function getNamehash(name) {\n  const rootHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n  if (name !== \"\") {\n    const labels = name.split(\".\");\n    const namehash = reduceRight(labels, appendHash, rootHash);\n    trace(`Namehash for ${name} is ${namehash}`);\n    return namehash;\n  }\n\n  return rootHash;\n}\n\nconst getResolverContract = async addr => {\n  trace(\"Instantiating resolver contract\");\n  const web3 = await getWeb3();\n  const resolver = new web3.eth.Contract(resolverABI, addr);\n  return {\n    resolver\n  };\n};\n\nconst getENSContract = async () => {\n  const web3 = await getWeb3();\n  const networkId = await web3.eth.net.getId();\n  trace(`Instantiating ENS Contract for networkID: ${networkId}`);\n  const ens = new web3.eth.Contract(ensContractABI, ensRegistryContractAddress[networkId].registry);\n  trace(`ENS Contract instantiated: ${ens}`);\n  trace(ens);\n  return ens;\n};\n\nconst getResolverContractForDomain = async domain => {\n  const ens = await getENSContract();\n  const node = getNamehash(domain);\n  const resolverContractAddress = await ens.methods.resolver(node).call();\n  trace(`Got resolver address for ${domain}: ${resolverContractAddress}`);\n  const {\n    resolver\n  } = await getResolverContract(resolverContractAddress);\n  return resolver;\n};\n\nexport const getAddr = async domain => {\n  try {\n    trace(`Attempting to resolve: ${domain}`);\n    const node = getNamehash(domain);\n    const resolver = await getResolverContractForDomain(domain);\n    trace(resolver);\n    const setAddrMethod = resolver.methods.addr(node);\n    const address = await setAddrMethod.call();\n    trace(`Resolution of ${domain} resulted in: ${address}`);\n    return address;\n  } catch (err) {\n    error(err);\n    throw err;\n  }\n};\nexport const getText = async (domain, recordType) => {\n  try {\n    // TODO: in uncontrolled environments should call supportsInterface(\"0x59d1d43c\") to check if text records are supported on this resolver\n    const node = getNamehash(domain);\n    const resolver = await getResolverContractForDomain(domain);\n    trace(`Calling getText:${recordType} on ENS for ${domain}`);\n    const getTextMethod = resolver.methods.text(node, recordType);\n    const text = await getTextMethod.call();\n    trace(`Retrieving text record ${recordType} of ${domain} resulted in: ${text}`);\n    return text;\n  } catch (err) {\n    error(err);\n    throw err;\n  }\n};\nexport const getName = async domain => {\n  const resolverContractAddress = \"0xcAcbE14d88380F8eb37ec0d7788ec226EE7b3434\";\n  const {\n    resolver\n  } = await getResolverContract(resolverContractAddress);\n  const node = await getNamehash(domain);\n  const setAddrMethod = resolver.methods.addr(node);\n  return setAddrMethod.call();\n};","map":null,"metadata":{},"sourceType":"module"}