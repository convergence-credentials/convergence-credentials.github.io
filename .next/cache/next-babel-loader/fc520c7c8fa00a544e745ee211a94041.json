{"ast":null,"code":"import { stripHexPrefix, bufferToHex, keccak256 } from \"ethereumjs-util\";\nimport { reduceRight } from \"lodash\";\nimport ensContractABI from \"./contracts/ensContract.json\";\nimport resolverABI from \"./contracts/resolverContract.json\";\nimport { getWeb3 } from \"../web3\";\nimport { getLogger } from \"../../utils/logger\";\nconst {\n  trace,\n  error\n} = getLogger(\"services:ens\"); // Well-known addresses for ENS registry contracts\n\nconst ensRegistryContractAddress = {\n  1: {\n    registry: \"0x314159265dd8dbb310642f98f50c066173c1259b\"\n  },\n  3: {\n    registry: \"0x112234455c3a32fd11230c42e7bccd4a84e02010\"\n  }\n};\n\nfunction keccak256String(label) {\n  return bufferToHex(keccak256(label));\n}\n\nfunction appendHash(node, label) {\n  return keccak256String(node + stripHexPrefix(keccak256String(label)));\n}\n\nexport function getNamehash(name) {\n  const rootHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n  if (name !== \"\") {\n    const labels = name.split(\".\");\n    const namehash = reduceRight(labels, appendHash, rootHash);\n    trace(`Namehash for ${name} is ${namehash}`);\n    return namehash;\n  }\n\n  return rootHash;\n}\n\nconst getResolverContract = async addr => {\n  trace(\"Instantiating resolver contract\");\n  const web3 = await getWeb3();\n  const resolver = new web3.eth.Contract(resolverABI, addr);\n  return {\n    resolver\n  };\n};\n\nconst getENSContract = async () => {\n  const web3 = await getWeb3();\n  const networkId = await web3.eth.net.getId();\n  trace(`Instantiating ENS Contract for networkID: ${networkId}`);\n  const ens = new web3.eth.Contract(ensContractABI, ensRegistryContractAddress[networkId].registry);\n  trace(`ENS Contract instantiated: ${ens}`);\n  trace(ens);\n  return ens;\n};\n\nconst getResolverContractForDomain = async domain => {\n  const ens = await getENSContract();\n  const node = getNamehash(domain);\n  const resolverContractAddress = await ens.methods.resolver(node).call();\n  trace(`Got resolver address for ${domain}: ${resolverContractAddress}`);\n  const {\n    resolver\n  } = await getResolverContract(resolverContractAddress);\n  return resolver;\n};\n\nexport const getAddr = async domain => {\n  try {\n    trace(`Attempting to resolve: ${domain}`);\n    const node = getNamehash(domain);\n    const resolver = await getResolverContractForDomain(domain);\n    trace(resolver);\n    const setAddrMethod = resolver.methods.addr(node);\n    const address = await setAddrMethod.call();\n    trace(`Resolution of ${domain} resulted in: ${address}`);\n    return address;\n  } catch (err) {\n    error(err);\n    throw err;\n  }\n};\nexport const getText = async (domain, recordType) => {\n  try {\n    // TODO: in uncontrolled environments should call supportsInterface(\"0x59d1d43c\") to check if text records are supported on this resolver\n    const node = getNamehash(domain);\n    const resolver = await getResolverContractForDomain(domain);\n    trace(`Calling getText:${recordType} on ENS for ${domain}`);\n    const getTextMethod = resolver.methods.text(node, recordType);\n    const text = await getTextMethod.call();\n    trace(`Retrieving text record ${recordType} of ${domain} resulted in: ${text}`);\n    return text;\n  } catch (err) {\n    error(err);\n    throw err;\n  }\n};\nexport const getName = async domain => {\n  const resolverContractAddress = \"0xcAcbE14d88380F8eb37ec0d7788ec226EE7b3434\";\n  const {\n    resolver\n  } = await getResolverContract(resolverContractAddress);\n  const node = await getNamehash(domain);\n  const setAddrMethod = resolver.methods.addr(node);\n  return setAddrMethod.call();\n};","map":{"version":3,"sources":["/home/ajl/development/ssi/academic-creds/convergence-credentials.github.io/src/services/ens/ens.js"],"names":["stripHexPrefix","bufferToHex","keccak256","reduceRight","ensContractABI","resolverABI","getWeb3","getLogger","trace","error","ensRegistryContractAddress","registry","keccak256String","label","appendHash","node","getNamehash","name","rootHash","labels","split","namehash","getResolverContract","addr","web3","resolver","eth","Contract","getENSContract","networkId","net","getId","ens","getResolverContractForDomain","domain","resolverContractAddress","methods","call","getAddr","setAddrMethod","address","err","getText","recordType","getTextMethod","text","getName"],"mappings":"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","sourcesContent":["import { stripHexPrefix, bufferToHex, keccak256 } from \"ethereumjs-util\";\nimport { reduceRight } from \"lodash\";\nimport ensContractABI from \"./contracts/ensContract.json\";\nimport resolverABI from \"./contracts/resolverContract.json\";\nimport { getWeb3 } from \"../web3\";\nimport { getLogger } from \"../../utils/logger\";\n\nconst { trace, error } = getLogger(\"services:ens\");\n\n// Well-known addresses for ENS registry contracts\nconst ensRegistryContractAddress = {\n  1: {\n    registry: \"0x314159265dd8dbb310642f98f50c066173c1259b\"\n  },\n  3: {\n    registry: \"0x112234455c3a32fd11230c42e7bccd4a84e02010\"\n  }\n};\n\nfunction keccak256String(label) {\n  return bufferToHex(keccak256(label));\n}\n\nfunction appendHash(node, label) {\n  return keccak256String(node + stripHexPrefix(keccak256String(label)));\n}\n\nexport function getNamehash(name) {\n  const rootHash =\n    \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n  if (name !== \"\") {\n    const labels = name.split(\".\");\n    const namehash = reduceRight(labels, appendHash, rootHash);\n    trace(`Namehash for ${name} is ${namehash}`);\n    return namehash;\n  }\n  return rootHash;\n}\n\nconst getResolverContract = async addr => {\n  trace(\"Instantiating resolver contract\");\n  const web3 = await getWeb3();\n  const resolver = new web3.eth.Contract(resolverABI, addr);\n  return {\n    resolver\n  };\n};\n\nconst getENSContract = async () => {\n  const web3 = await getWeb3();\n  const networkId = await web3.eth.net.getId();\n  trace(`Instantiating ENS Contract for networkID: ${networkId}`);\n  const ens = new web3.eth.Contract(\n    ensContractABI,\n    ensRegistryContractAddress[networkId].registry\n  );\n  trace(`ENS Contract instantiated: ${ens}`);\n  trace(ens);\n  return ens;\n};\n\nconst getResolverContractForDomain = async domain => {\n  const ens = await getENSContract();\n  const node = getNamehash(domain);\n  const resolverContractAddress = await ens.methods.resolver(node).call();\n  trace(`Got resolver address for ${domain}: ${resolverContractAddress}`);\n  const { resolver } = await getResolverContract(resolverContractAddress);\n  return resolver;\n};\n\nexport const getAddr = async domain => {\n  try {\n    trace(`Attempting to resolve: ${domain}`);\n    const node = getNamehash(domain);\n    const resolver = await getResolverContractForDomain(domain);\n    trace(resolver);\n    const setAddrMethod = resolver.methods.addr(node);\n    const address = await setAddrMethod.call();\n    trace(`Resolution of ${domain} resulted in: ${address}`);\n    return address;\n  } catch (err) {\n    error(err);\n    throw err;\n  }\n};\n\nexport const getText = async (domain, recordType) => {\n  try {\n    // TODO: in uncontrolled environments should call supportsInterface(\"0x59d1d43c\") to check if text records are supported on this resolver\n    const node = getNamehash(domain);\n    const resolver = await getResolverContractForDomain(domain);\n\n    trace(`Calling getText:${recordType} on ENS for ${domain}`);\n    const getTextMethod = resolver.methods.text(node, recordType);\n    const text = await getTextMethod.call();\n    trace(\n      `Retrieving text record ${recordType} of ${domain} resulted in: ${text}`\n    );\n    return text;\n  } catch (err) {\n    error(err);\n    throw err;\n  }\n};\n\nexport const getName = async domain => {\n  const resolverContractAddress = \"0xcAcbE14d88380F8eb37ec0d7788ec226EE7b3434\";\n  const { resolver } = await getResolverContract(resolverContractAddress);\n  const node = await getNamehash(domain);\n  const setAddrMethod = resolver.methods.addr(node);\n  return setAddrMethod.call();\n};\n"]},"metadata":{},"sourceType":"module"}