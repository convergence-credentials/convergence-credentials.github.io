{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"@babel/runtime-corejs2/helpers/esm/taggedTemplateLiteral\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _marked =\n/*#__PURE__*/\n_regeneratorRuntime.mark(loadCertificateContracts),\n    _marked2 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(isValidENSDomain),\n    _marked3 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(isValidSmartContract),\n    _marked4 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateStore),\n    _marked5 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateHash),\n    _marked6 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateIssued),\n    _marked7 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateNotRevoked),\n    _marked8 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(lookupAddressOnRegistry),\n    _marked9 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(resolveEnsNameToText),\n    _marked10 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateDnsIssuer),\n    _marked11 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateRegistryIssuer),\n    _marked12 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(getDetailedIssuerStatus),\n    _marked13 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificateIssuer),\n    _marked14 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(verifyCertificate),\n    _marked15 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(sendCertificate),\n    _marked16 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(networkReset),\n    _marked17 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(getAnalyticsDetails),\n    _marked18 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(triggerAnalytics),\n    _marked19 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsIssuerFail),\n    _marked20 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsHashFail),\n    _marked21 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsIssuedFail),\n    _marked22 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsRevocationFail),\n    _marked23 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(analyticsStoreFail);\n\nimport { some, get, partition, compact, mapKeys } from \"lodash\";\nimport { put, all, call, select, takeEvery } from \"redux-saga/effects\";\nimport { getData, verifySignature } from \"@govtechsg/open-attestation\";\nimport { isValidAddress as isEthereumAddress } from \"ethereumjs-util\";\nimport Router from \"next/router\";\nimport { getDocumentStoreRecords } from \"@govtechsg/dnsprove\";\nimport { getLogger } from \"../utils/logger\";\nimport { types, verifyingCertificateIssuerSuccess, verifyingCertificateIssuerFailure, verifyingCertificateRevocationSuccess, verifyingCertificateRevocationFailure, verifyingCertificateIssuedSuccess, verifyingCertificateIssuedFailure, verifyingCertificateHashSuccess, verifyingCertificateHashFailure, verifyingCertificateStoreSuccess, verifyingCertificateStoreFailure, getCertificate } from \"../reducers/certificate\";\nimport { types as applicationTypes } from \"../reducers/application\";\nimport DocumentStoreDefinition from \"../services/contracts/DocumentStore.json\";\nimport fetchIssuers from \"../services/issuers\";\nimport { combinedHash } from \"../utils\";\nimport { ensResolveAddress, getText } from \"../services/ens\";\nimport sendEmail from \"../services/email\";\nimport { analyticsEvent } from \"../components/Analytics\";\nimport { getDocumentStore, getDocumentIssuerStores } from \"../utils/certificate\";\nimport { getSelectedWeb3 } from \"./application\";\nimport { IS_MAINNET } from \"../config\";\n\nvar _getLogger = getLogger(\"saga:certificate\"),\n    trace = _getLogger.trace,\n    error = _getLogger.error;\n\nvar ANALYTICS_VERIFICATION_ERROR_CODE = {\n  ISSUER_IDENTITY: 0,\n  CERTIFICATE_HASH: 1,\n  UNISSUED_CERTIFICATE: 2,\n  REVOKED_CERTIFICATE: 3,\n  CERTIFICATE_STORE: 4\n};\nexport function loadCertificateContracts(_ref) {\n  var payload, data, unresolvedContractStoreAddresses, web3, contractStoreAddresses, abi, contracts;\n  return _regeneratorRuntime.wrap(function loadCertificateContracts$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          payload = _ref.payload;\n          _context.prev = 1;\n          data = getData(payload);\n          trace(\"Loading certificate: \".concat(data));\n          unresolvedContractStoreAddresses = get(data, \"issuers\", []).map(function (issuer) {\n            return getDocumentStore(issuer);\n          });\n          _context.next = 7;\n          return getSelectedWeb3();\n\n        case 7:\n          web3 = _context.sent;\n          _context.next = 10;\n          return all(unresolvedContractStoreAddresses.map(function (unresolvedAddress) {\n            return call(ensResolveAddress, unresolvedAddress);\n          }));\n\n        case 10:\n          contractStoreAddresses = _context.sent;\n          trace(\"Resolved certificate's store addresses, \".concat(contractStoreAddresses));\n          abi = DocumentStoreDefinition.abi;\n          contracts = contractStoreAddresses.map(function (address) {\n            return new web3.eth.Contract(abi, address);\n          });\n          _context.next = 16;\n          return put({\n            type: types.LOADING_STORE_SUCCESS\n          });\n\n        case 16:\n          return _context.abrupt(\"return\", contracts);\n\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context[\"catch\"](1);\n          _context.next = 23;\n          return put({\n            type: types.LOADING_STORE_FAILURE,\n            payload: _context.t0\n          });\n\n        case 23:\n          return _context.abrupt(\"return\", null);\n\n        case 24:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 19]]);\n}\nexport function isValidENSDomain(storeAddress) {\n  var web3, ensToAddress;\n  return _regeneratorRuntime.wrap(function isValidENSDomain$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          trace(\"Checking if \".concat(storeAddress, \" is a valid ENS Domain\"));\n\n          if (!(storeAddress == null)) {\n            _context2.next = 3;\n            break;\n          }\n\n          throw new Error(\"No address in certificate\");\n\n        case 3:\n          _context2.next = 5;\n          return getSelectedWeb3();\n\n        case 5:\n          web3 = _context2.sent;\n          _context2.next = 8;\n          return web3.eth.ens.getAddress(storeAddress);\n\n        case 8:\n          ensToAddress = _context2.sent;\n\n          if (!(ensToAddress === null)) {\n            _context2.next = 11;\n            break;\n          }\n\n          throw new Error(\"Invalid ENS\");\n\n        case 11:\n          return _context2.abrupt(\"return\", ensToAddress);\n\n        case 12:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\nexport function isValidSmartContract(storeAddress) {\n  var web3, supportedContractHashes, onChainByteCode, hashOfOnChainByteCode;\n  return _regeneratorRuntime.wrap(function isValidSmartContract$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return getSelectedWeb3();\n\n        case 2:\n          web3 = _context3.sent;\n          supportedContractHashes = [\"0x7135575eac76f1817c27b06c452bdc2b7e1b13240797415684e227def063a127\"];\n          _context3.next = 6;\n          return web3.eth.getCode(storeAddress);\n\n        case 6:\n          onChainByteCode = _context3.sent;\n          hashOfOnChainByteCode = web3.utils.keccak256(onChainByteCode);\n\n          if (supportedContractHashes.includes(hashOfOnChainByteCode)) {\n            _context3.next = 10;\n            break;\n          }\n\n          throw new Error(\"Invalid smart contract: \"(_templateObject(), storeAddress));\n\n        case 10:\n          return _context3.abrupt(\"return\", true);\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}\nexport function verifyCertificateStore(_ref2) {\n  var certificate, data, contractStoreAddresses, _partition, _partition2, ethereumAddressIssuers, unresolvedEnsNames, resolvedEnsNames, combinedStoreAddresses;\n\n  return _regeneratorRuntime.wrap(function verifyCertificateStore$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          certificate = _ref2.certificate;\n          _context4.prev = 1;\n          data = getData(certificate);\n          contractStoreAddresses = get(data, \"issuers\", []).map(function (issuer) {\n            return getDocumentStore(issuer);\n          });\n          trace(\"Attempting to verify certificate store: \".concat(contractStoreAddresses));\n          _partition = partition(contractStoreAddresses, isEthereumAddress), _partition2 = _slicedToArray(_partition, 2), ethereumAddressIssuers = _partition2[0], unresolvedEnsNames = _partition2[1];\n          trace(\"ethereumAddressIssuers\", ethereumAddressIssuers);\n          trace(\"unresolvedEnsNames\", unresolvedEnsNames);\n          _context4.next = 10;\n          return unresolvedEnsNames.map(function (unresolvedEnsName) {\n            return call(isValidENSDomain, unresolvedEnsName);\n          });\n\n        case 10:\n          resolvedEnsNames = _context4.sent;\n          // Concat the 2 arrays\n          combinedStoreAddresses = compact(ethereumAddressIssuers.concat(resolvedEnsNames)); // Checks if issuing institution has a valid smart contract with OpenCerts\n\n          _context4.next = 14;\n          return combinedStoreAddresses.map(function (address) {\n            return isValidSmartContract(address);\n          });\n\n        case 14:\n          _context4.next = 16;\n          return put(verifyingCertificateStoreSuccess());\n\n        case 16:\n          return _context4.abrupt(\"return\", combinedStoreAddresses);\n\n        case 19:\n          _context4.prev = 19;\n          _context4.t0 = _context4[\"catch\"](1);\n          error(_context4.t0);\n          _context4.next = 24;\n          return put(verifyingCertificateStoreFailure({\n            error: _context4.t0.message\n          }));\n\n        case 24:\n          return _context4.abrupt(\"return\", false);\n\n        case 25:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4, null, [[1, 19]]);\n}\nexport function verifyCertificateHash(_ref3) {\n  var certificate, verified, hashError;\n  return _regeneratorRuntime.wrap(function verifyCertificateHash$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          certificate = _ref3.certificate;\n          verified = verifySignature(certificate);\n\n          if (!verified) {\n            _context5.next = 6;\n            break;\n          }\n\n          _context5.next = 5;\n          return put(verifyingCertificateHashSuccess());\n\n        case 5:\n          return _context5.abrupt(\"return\", true);\n\n        case 6:\n          hashError = new Error(\"Certificate data does not match target hash\");\n          error(hashError);\n          _context5.next = 10;\n          return put(verifyingCertificateHashFailure({\n            error: hashError.message\n          }));\n\n        case 10:\n          return _context5.abrupt(\"return\", false);\n\n        case 11:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5);\n}\nexport function verifyCertificateIssued(_ref4) {\n  var certificate, certificateStores, merkleRoot, issuedStatuses, isIssued;\n  return _regeneratorRuntime.wrap(function verifyCertificateIssued$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          certificate = _ref4.certificate, certificateStores = _ref4.certificateStores;\n          _context6.prev = 1;\n          merkleRoot = \"0x\".concat(get(certificate, \"signature.merkleRoot\", \"\")); // Checks if certificate has been issued on ALL store\n\n          _context6.next = 5;\n          return all(certificateStores.map(function (store) {\n            return store.methods.isIssued(merkleRoot).call();\n          }));\n\n        case 5:\n          issuedStatuses = _context6.sent;\n\n          if (!(issuedStatuses.length === 0)) {\n            _context6.next = 8;\n            break;\n          }\n\n          throw new Error(\"Invalid file\");\n\n        case 8:\n          isIssued = issuedStatuses.reduce(function (prev, curr) {\n            return prev && curr;\n          }, true);\n\n          if (isIssued) {\n            _context6.next = 11;\n            break;\n          }\n\n          throw new Error(\"Certificate has not been issued\");\n\n        case 11:\n          _context6.next = 13;\n          return put(verifyingCertificateIssuedSuccess());\n\n        case 13:\n          return _context6.abrupt(\"return\", true);\n\n        case 16:\n          _context6.prev = 16;\n          _context6.t0 = _context6[\"catch\"](1);\n          error(_context6.t0);\n          _context6.next = 21;\n          return put(verifyingCertificateIssuedFailure({\n            error: _context6.t0.message\n          }));\n\n        case 21:\n          return _context6.abrupt(\"return\", false);\n\n        case 22:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked6, null, [[1, 16]]);\n}\nexport var getIntermediateHashes = function getIntermediateHashes(targetHash) {\n  var proof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // Returns hash of all intermediate hashes from targetHash to merkleRoot\n  var intermediateHashes = [\"0x\".concat(targetHash)];\n  proof.reduce(function (accumulator, currentValue) {\n    var combined = combinedHash(accumulator, currentValue).toString(\"hex\");\n    intermediateHashes.push(\"0x\".concat(combined));\n    return combined;\n  }, targetHash);\n  return intermediateHashes;\n};\nexport function verifyCertificateNotRevoked(_ref5) {\n  var certificate, certificateStores, targetHash, proof, intermediateHashes, _loop, i;\n\n  return _regeneratorRuntime.wrap(function verifyCertificateNotRevoked$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          certificate = _ref5.certificate, certificateStores = _ref5.certificateStores;\n          _context8.prev = 1;\n          targetHash = get(certificate, \"signature.targetHash\", null);\n          proof = get(certificate, \"signature.proof\", null); // Checks if certificate and path towards merkle root has been revoked\n\n          intermediateHashes = getIntermediateHashes(targetHash, proof);\n          _loop =\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _loop(i) {\n            var hash, revokedStatus, isRevoked;\n            return _regeneratorRuntime.wrap(function _loop$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    hash = intermediateHashes[i]; // Check if certificate is revoked on ALL store\n\n                    _context7.next = 3;\n                    return all(certificateStores.map(function (store) {\n                      return store.methods.isRevoked(hash).call();\n                    }));\n\n                  case 3:\n                    revokedStatus = _context7.sent;\n                    isRevoked = revokedStatus.reduce(function (prev, curr) {\n                      return prev || curr;\n                    }, false);\n\n                    if (!isRevoked) {\n                      _context7.next = 7;\n                      break;\n                    }\n\n                    throw new Error(\"Certificate has been revoked, revoked hash: \".concat(hash));\n\n                  case 7:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _loop);\n          });\n          i = 0;\n\n        case 7:\n          if (!(i < intermediateHashes.length)) {\n            _context8.next = 12;\n            break;\n          }\n\n          return _context8.delegateYield(_loop(i), \"t0\", 9);\n\n        case 9:\n          i += 1;\n          _context8.next = 7;\n          break;\n\n        case 12:\n          _context8.next = 14;\n          return put(verifyingCertificateRevocationSuccess());\n\n        case 14:\n          return _context8.abrupt(\"return\", true);\n\n        case 17:\n          _context8.prev = 17;\n          _context8.t1 = _context8[\"catch\"](1);\n          error(_context8.t1);\n          _context8.next = 22;\n          return put(verifyingCertificateRevocationFailure({\n            error: _context8.t1.message\n          }));\n\n        case 22:\n          return _context8.abrupt(\"return\", false);\n\n        case 23:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, _marked7, null, [[1, 17]]);\n}\n\nfunction isApprovedENSDomain(issuerAddress) {\n  trace(\"Checking if \".concat(issuerAddress, \" is opencerts TLD\"));\n  var approvedENSDomains = [/(opencerts.eth)$/];\n  return some(approvedENSDomains.map(function (domainMask) {\n    return domainMask.test(issuerAddress.toLowerCase());\n  }));\n}\n\nexport function lookupAddressOnRegistry(ethereumAddressIssuer) {\n  var registeredIssuers, issuersNormalised, identity;\n  return _regeneratorRuntime.wrap(function lookupAddressOnRegistry$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.next = 2;\n          return fetchIssuers();\n\n        case 2:\n          registeredIssuers = _context9.sent;\n          issuersNormalised = mapKeys(registeredIssuers, function (_, k) {\n            return k.toUpperCase();\n          });\n          identity = issuersNormalised[ethereumAddressIssuer.toUpperCase()];\n\n          if (identity) {\n            _context9.next = 7;\n            break;\n          }\n\n          throw new Error(\"Issuer identity cannot be verified: \".concat(ethereumAddressIssuer));\n\n        case 7:\n          return _context9.abrupt(\"return\", identity);\n\n        case 8:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, _marked8);\n}\nexport function resolveEnsNameToText(ensName) {\n  var invalidEnsError, getTextResult;\n  return _regeneratorRuntime.wrap(function resolveEnsNameToText$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          trace(\"resolving \", ensName);\n\n          if (isApprovedENSDomain(ensName)) {\n            _context10.next = 5;\n            break;\n          }\n\n          invalidEnsError = new Error(\"Issuer identity cannot be verified: \".concat(ensName));\n          error(invalidEnsError);\n          throw invalidEnsError;\n\n        case 5:\n          _context10.next = 7;\n          return call(getText, ensName, \"issuerName\");\n\n        case 7:\n          getTextResult = _context10.sent;\n          trace(\"Got texts records for \".concat(ensName), getTextResult);\n          return _context10.abrupt(\"return\", getTextResult);\n\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, _marked9);\n}\nexport function verifyCertificateDnsIssuer(_ref6) {\n  var issuer, location, dnsRecords, verificationStatus, documentStore;\n  return _regeneratorRuntime.wrap(function verifyCertificateDnsIssuer$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          issuer = _ref6.issuer;\n          location = get(issuer, \"identityProof.location\");\n\n          if (location) {\n            _context11.next = 4;\n            break;\n          }\n\n          return _context11.abrupt(\"return\", false);\n\n        case 4:\n          _context11.next = 6;\n          return call(getDocumentStoreRecords, location);\n\n        case 6:\n          dnsRecords = _context11.sent;\n          trace(\"DNS records: \".concat(_JSON$stringify(dnsRecords))); // dnsRecords: [{addr: \"0xabc\", netId: 3}]\n\n          verificationStatus = false;\n          documentStore = getDocumentStore(issuer);\n\n          if (dnsRecords && dnsRecords.length > 0) {\n            verificationStatus = dnsRecords.find(function (dns) {\n              return dns.addr === documentStore && dns.netId === (IS_MAINNET ? \"1\" : \"3\");\n            });\n          }\n\n          trace(\"DNS Verification Status: \".concat(_JSON$stringify(verificationStatus)));\n          return _context11.abrupt(\"return\", verificationStatus ? location : false);\n\n        case 13:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, _marked10);\n}\nexport function verifyCertificateRegistryIssuer(_ref7) {\n  var issuer, contractStoreAddresses, isValidEthereumAddress, issuerIdentitiesFromRegistry;\n  return _regeneratorRuntime.wrap(function verifyCertificateRegistryIssuer$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          issuer = _ref7.issuer;\n          _context12.prev = 1;\n          contractStoreAddresses = getDocumentStore(issuer);\n          trace(\"Attempting to verify certificate issuers: \".concat(contractStoreAddresses));\n          isValidEthereumAddress = isEthereumAddress(contractStoreAddresses);\n\n          if (isValidEthereumAddress) {\n            _context12.next = 7;\n            break;\n          }\n\n          throw new Error(\"\".concat(contractStoreAddresses, \" is not a valid Ethereum Address\"));\n\n        case 7:\n          trace(\"isValidEthereumAddress\", contractStoreAddresses);\n          _context12.next = 10;\n          return call(lookupAddressOnRegistry, contractStoreAddresses);\n\n        case 10:\n          issuerIdentitiesFromRegistry = _context12.sent;\n          trace(\"Resolved ethereum address \".concat(contractStoreAddresses, \" to \").concat(issuerIdentitiesFromRegistry));\n          return _context12.abrupt(\"return\", get(issuerIdentitiesFromRegistry, \"name\") || false);\n\n        case 15:\n          _context12.prev = 15;\n          _context12.t0 = _context12[\"catch\"](1);\n          return _context12.abrupt(\"return\", false);\n\n        case 18:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, _marked11, null, [[1, 15]]);\n}\n\nfunction throwIfAnyIdentityIsNotVerified(verificationStatuses) {\n  if (verificationStatuses.length === 0) throw new Error(\"No issuers found in the document\");\n  var invalidIdentities = verificationStatuses.filter(function (status) {\n    return !status.registry && !status.dns;\n  });\n\n  if (invalidIdentities.length > 0) {\n    var invalidStoreAddresses = invalidIdentities.map(function (identity) {\n      return identity.documentStore;\n    });\n    throw new Error(\"Issuer identity cannot be verified: \".concat(invalidStoreAddresses.join(\", \")));\n  }\n}\n\nexport function getDetailedIssuerStatus(_ref8) {\n  var issuer, verificationStatus;\n  return _regeneratorRuntime.wrap(function getDetailedIssuerStatus$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          issuer = _ref8.issuer;\n          verificationStatus = {\n            documentStore: getDocumentStore(issuer),\n            registry: null,\n            dns: null\n          };\n          _context13.next = 4;\n          return call(verifyCertificateRegistryIssuer, {\n            issuer: issuer\n          });\n\n        case 4:\n          verificationStatus.registry = _context13.sent;\n\n          if (!(get(issuer, \"identityProof.type\") === \"DNS-TXT\")) {\n            _context13.next = 9;\n            break;\n          }\n\n          _context13.next = 8;\n          return call(verifyCertificateDnsIssuer, {\n            issuer: issuer\n          });\n\n        case 8:\n          verificationStatus.dns = _context13.sent;\n\n        case 9:\n          trace(\"issuer status: \".concat(_JSON$stringify(verificationStatus)));\n          return _context13.abrupt(\"return\", verificationStatus);\n\n        case 11:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, _marked12);\n}\nexport function verifyCertificateIssuer(_ref9) {\n  var certificate, data, issuers, verificationStatuses;\n  return _regeneratorRuntime.wrap(function verifyCertificateIssuer$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          certificate = _ref9.certificate;\n          _context14.prev = 1;\n          data = getData(certificate);\n          issuers = get(data, \"issuers\", []); // verificationStatuses: [{dns: \"abc.com\", registry:\"Govtech\", documentStore: \"0xabc\"}]\n\n          _context14.next = 6;\n          return all(issuers.map(function (issuer) {\n            return call(getDetailedIssuerStatus, {\n              issuer: issuer\n            });\n          }));\n\n        case 6:\n          verificationStatuses = _context14.sent;\n          // If any identity is not verified, this should return false\n          throwIfAnyIdentityIsNotVerified(verificationStatuses);\n          _context14.next = 10;\n          return put(verifyingCertificateIssuerSuccess({\n            issuerIdentities: verificationStatuses\n          }));\n\n        case 10:\n          return _context14.abrupt(\"return\", true);\n\n        case 13:\n          _context14.prev = 13;\n          _context14.t0 = _context14[\"catch\"](1);\n          error(_context14.t0);\n          _context14.next = 18;\n          return put(verifyingCertificateIssuerFailure({\n            error: _context14.t0.message\n          }));\n\n        case 18:\n          return _context14.abrupt(\"return\", false);\n\n        case 19:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, _marked13, null, [[1, 13]]);\n}\nexport function verifyCertificate(_ref10) {\n  var payload, certificateStores, args, verificationStatuses, verified;\n  return _regeneratorRuntime.wrap(function verifyCertificate$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          payload = _ref10.payload;\n          _context15.next = 3;\n          return put({\n            type: types.VERIFYING_CERTIFICATE\n          });\n\n        case 3:\n          _context15.next = 5;\n          return call(loadCertificateContracts, {\n            payload: payload\n          });\n\n        case 5:\n          certificateStores = _context15.sent;\n          args = {\n            certificateStores: certificateStores,\n            certificate: payload\n          };\n          _context15.next = 9;\n          return all({\n            certificateIssued: call(verifyCertificateIssued, args),\n            certificateHashValid: call(verifyCertificateHash, args),\n            certificateNotRevoked: call(verifyCertificateNotRevoked, args),\n            certificateIssuerRecognised: call(verifyCertificateIssuer, args),\n            certificateStoreValid: call(verifyCertificateStore, args)\n          });\n\n        case 9:\n          verificationStatuses = _context15.sent;\n          trace(verificationStatuses);\n          verified = verificationStatuses.certificateIssued && verificationStatuses.certificateHashValid && verificationStatuses.certificateNotRevoked && verificationStatuses.certificateIssuerRecognised && verificationStatuses.certificateStoreValid;\n\n          if (verified) {\n            Router.push(\"/viewer\");\n          }\n\n        case 13:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, _marked14);\n}\nexport function sendCertificate(_ref11) {\n  var payload, certificate, email, captcha, success;\n  return _regeneratorRuntime.wrap(function sendCertificate$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          payload = _ref11.payload;\n          _context16.prev = 1;\n          _context16.next = 4;\n          return select(getCertificate);\n\n        case 4:\n          certificate = _context16.sent;\n          email = payload.email, captcha = payload.captcha;\n          _context16.next = 8;\n          return sendEmail({\n            certificate: certificate,\n            email: email,\n            captcha: captcha\n          });\n\n        case 8:\n          success = _context16.sent;\n\n          if (success) {\n            _context16.next = 11;\n            break;\n          }\n\n          throw new Error(\"Fail to send certificate\");\n\n        case 11:\n          _context16.next = 13;\n          return put({\n            type: types.SENDING_CERTIFICATE_SUCCESS\n          });\n\n        case 13:\n          _context16.next = 19;\n          break;\n\n        case 15:\n          _context16.prev = 15;\n          _context16.t0 = _context16[\"catch\"](1);\n          _context16.next = 19;\n          return put({\n            type: types.SENDING_CERTIFICATE_FAILURE,\n            payload: _context16.t0.message\n          });\n\n        case 19:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, _marked15, null, [[1, 15]]);\n}\nexport function networkReset() {\n  return _regeneratorRuntime.wrap(function networkReset$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _context17.next = 2;\n          return put({\n            type: types.NETWORK_RESET\n          });\n\n        case 2:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, _marked16);\n}\nexport function getAnalyticsDetails() {\n  var rawCertificate, certificate, storeAddresses, id;\n  return _regeneratorRuntime.wrap(function getAnalyticsDetails$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          _context18.prev = 0;\n          _context18.next = 3;\n          return select(getCertificate);\n\n        case 3:\n          rawCertificate = _context18.sent;\n          certificate = getData(rawCertificate);\n          storeAddresses = getDocumentIssuerStores(certificate);\n          id = get(certificate, \"id\");\n          return _context18.abrupt(\"return\", {\n            storeAddresses: storeAddresses,\n            id: id\n          });\n\n        case 10:\n          _context18.prev = 10;\n          _context18.t0 = _context18[\"catch\"](0);\n          return _context18.abrupt(\"return\", {});\n\n        case 13:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, _marked17, null, [[0, 10]]);\n}\nexport function triggerAnalytics(errorCode) {\n  var _ref12, storeAddresses, id;\n\n  return _regeneratorRuntime.wrap(function triggerAnalytics$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          _context19.next = 2;\n          return call(getAnalyticsDetails);\n\n        case 2:\n          _ref12 = _context19.sent;\n          storeAddresses = _ref12.storeAddresses;\n          id = _ref12.id;\n\n          if (storeAddresses && id) {\n            analyticsEvent(window, {\n              category: \"CERTIFICATE_ERROR\",\n              action: storeAddresses,\n              label: id,\n              value: errorCode\n            });\n          }\n\n        case 6:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, _marked18);\n}\nexport function analyticsIssuerFail() {\n  return _regeneratorRuntime.wrap(function analyticsIssuerFail$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _context20.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.ISSUER_IDENTITY);\n\n        case 2:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, _marked19);\n}\nexport function analyticsHashFail() {\n  return _regeneratorRuntime.wrap(function analyticsHashFail$(_context21) {\n    while (1) {\n      switch (_context21.prev = _context21.next) {\n        case 0:\n          _context21.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_HASH);\n\n        case 2:\n        case \"end\":\n          return _context21.stop();\n      }\n    }\n  }, _marked20);\n}\nexport function analyticsIssuedFail() {\n  return _regeneratorRuntime.wrap(function analyticsIssuedFail$(_context22) {\n    while (1) {\n      switch (_context22.prev = _context22.next) {\n        case 0:\n          _context22.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.UNISSUED_CERTIFICATE);\n\n        case 2:\n        case \"end\":\n          return _context22.stop();\n      }\n    }\n  }, _marked21);\n}\nexport function analyticsRevocationFail() {\n  return _regeneratorRuntime.wrap(function analyticsRevocationFail$(_context23) {\n    while (1) {\n      switch (_context23.prev = _context23.next) {\n        case 0:\n          _context23.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.REVOKED_CERTIFICATE);\n\n        case 2:\n        case \"end\":\n          return _context23.stop();\n      }\n    }\n  }, _marked22);\n}\nexport function analyticsStoreFail() {\n  return _regeneratorRuntime.wrap(function analyticsStoreFail$(_context24) {\n    while (1) {\n      switch (_context24.prev = _context24.next) {\n        case 0:\n          _context24.next = 2;\n          return call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_STORE);\n\n        case 2:\n        case \"end\":\n          return _context24.stop();\n      }\n    }\n  }, _marked23);\n}\nexport default [takeEvery(types.UPDATE_CERTIFICATE, verifyCertificate), takeEvery(types.SENDING_CERTIFICATE, sendCertificate), takeEvery(applicationTypes.UPDATE_WEB3, networkReset), takeEvery(types.VERIFYING_CERTIFICATE_ISSUER_FAILURE, analyticsIssuerFail), takeEvery(types.VERIFYING_CERTIFICATE_REVOCATION_FAILURE, analyticsRevocationFail), takeEvery(types.VERIFYING_CERTIFICATE_ISSUED_FAILURE, analyticsIssuedFail), takeEvery(types.VERIFYING_CERTIFICATE_HASH_FAILURE, analyticsHashFail), takeEvery(types.VERIFYING_CERTIFICATE_STORE_FAILURE, analyticsStoreFail)];","map":null,"metadata":{},"sourceType":"module"}