{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport { some, get, partition, compact, mapKeys } from \"lodash\";\nimport { put, all, call, select, takeEvery } from \"redux-saga/effects\";\nimport { getData, verifySignature } from \"@govtechsg/open-attestation\";\nimport { isValidAddress as isEthereumAddress } from \"ethereumjs-util\";\nimport Router from \"next/router\";\nimport { getDocumentStoreRecords } from \"@govtechsg/dnsprove\";\nimport { getLogger } from \"../utils/logger\";\nimport { types, verifyingCertificateIssuerSuccess, verifyingCertificateIssuerFailure, verifyingCertificateRevocationSuccess, verifyingCertificateRevocationFailure, verifyingCertificateIssuedSuccess, verifyingCertificateIssuedFailure, verifyingCertificateHashSuccess, verifyingCertificateHashFailure, verifyingCertificateStoreSuccess, verifyingCertificateStoreFailure, getCertificate } from \"../reducers/certificate\";\nimport { types as applicationTypes } from \"../reducers/application\";\nimport DocumentStoreDefinition from \"../services/contracts/DocumentStore.json\";\nimport fetchIssuers from \"../services/issuers\";\nimport { combinedHash } from \"../utils\";\nimport { ensResolveAddress, getText } from \"../services/ens\";\nimport sendEmail from \"../services/email\";\nimport { analyticsEvent } from \"../components/Analytics\";\nimport { getDocumentStore, getDocumentIssuerStores } from \"../utils/certificate\";\nimport { getSelectedWeb3 } from \"./application\";\nimport { IS_MAINNET } from \"../config\";\nconst {\n  trace,\n  error\n} = getLogger(\"saga:certificate\");\nconst ANALYTICS_VERIFICATION_ERROR_CODE = {\n  ISSUER_IDENTITY: 0,\n  CERTIFICATE_HASH: 1,\n  UNISSUED_CERTIFICATE: 2,\n  REVOKED_CERTIFICATE: 3,\n  CERTIFICATE_STORE: 4\n};\nexport function* loadCertificateContracts({\n  payload\n}) {\n  try {\n    const data = getData(payload);\n    trace(`Loading certificate: ${data}`);\n    const unresolvedContractStoreAddresses = get(data, \"issuers\", []).map(issuer => getDocumentStore(issuer));\n    const web3 = yield getSelectedWeb3();\n    const contractStoreAddresses = yield all(unresolvedContractStoreAddresses.map(unresolvedAddress => call(ensResolveAddress, unresolvedAddress)));\n    trace(`Resolved certificate's store addresses, ${contractStoreAddresses}`);\n    const {\n      abi\n    } = DocumentStoreDefinition;\n    const contracts = contractStoreAddresses.map(address => new web3.eth.Contract(abi, address));\n    yield put({\n      type: types.LOADING_STORE_SUCCESS\n    });\n    return contracts;\n  } catch (e) {\n    yield put({\n      type: types.LOADING_STORE_FAILURE,\n      payload: e\n    });\n    return null;\n  }\n}\nexport function* isValidENSDomain(storeAddress) {\n  trace(`Checking if ${storeAddress} is a valid ENS Domain`);\n\n  if (storeAddress == null) {\n    throw new Error(\"No address in certificate\");\n  }\n\n  const web3 = yield getSelectedWeb3();\n  const ensToAddress = yield web3.eth.ens.getAddress(storeAddress);\n\n  if (ensToAddress === null) {\n    throw new Error(\"Invalid ENS\");\n  }\n\n  return ensToAddress;\n}\nexport function* isValidSmartContract(storeAddress) {\n  const web3 = yield getSelectedWeb3();\n  const supportedContractHashes = [\"0x7135575eac76f1817c27b06c452bdc2b7e1b13240797415684e227def063a127\"];\n  const onChainByteCode = yield web3.eth.getCode(storeAddress);\n  const hashOfOnChainByteCode = web3.utils.keccak256(onChainByteCode);\n\n  if (!supportedContractHashes.includes(hashOfOnChainByteCode)) {\n    throw new Error(\"Invalid smart contract: \"`${storeAddress}`);\n  }\n\n  return true;\n}\nexport function* verifyCertificateStore({\n  certificate\n}) {\n  try {\n    const data = getData(certificate);\n    const contractStoreAddresses = get(data, \"issuers\", []).map(issuer => getDocumentStore(issuer));\n    trace(`Attempting to verify certificate store: ${contractStoreAddresses}`);\n    const [ethereumAddressIssuers, unresolvedEnsNames] = partition(contractStoreAddresses, isEthereumAddress);\n    trace(\"ethereumAddressIssuers\", ethereumAddressIssuers);\n    trace(\"unresolvedEnsNames\", unresolvedEnsNames);\n    const resolvedEnsNames = yield unresolvedEnsNames.map(unresolvedEnsName => call(isValidENSDomain, unresolvedEnsName)); // Concat the 2 arrays\n\n    const combinedStoreAddresses = compact(ethereumAddressIssuers.concat(resolvedEnsNames)); // Checks if issuing institution has a valid smart contract with OpenCerts\n\n    yield combinedStoreAddresses.map(address => isValidSmartContract(address));\n    yield put(verifyingCertificateStoreSuccess());\n    return combinedStoreAddresses;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateStoreFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\nexport function* verifyCertificateHash({\n  certificate\n}) {\n  const verified = verifySignature(certificate);\n\n  if (verified) {\n    yield put(verifyingCertificateHashSuccess());\n    return true;\n  }\n\n  const hashError = new Error(\"Certificate data does not match target hash\");\n  error(hashError);\n  yield put(verifyingCertificateHashFailure({\n    error: hashError.message\n  }));\n  return false;\n}\nexport function* verifyCertificateIssued({\n  certificate,\n  certificateStores\n}) {\n  try {\n    const merkleRoot = `0x${get(certificate, \"signature.merkleRoot\", \"\")}`; // Checks if certificate has been issued on ALL store\n\n    const issuedStatuses = yield all(certificateStores.map(store => store.methods.isIssued(merkleRoot).call()));\n    if (issuedStatuses.length === 0) throw new Error(\"Invalid file\");\n    const isIssued = issuedStatuses.reduce((prev, curr) => prev && curr, true);\n    if (!isIssued) throw new Error(\"Certificate has not been issued\");\n    yield put(verifyingCertificateIssuedSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateIssuedFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\nexport const getIntermediateHashes = (targetHash, proof = []) => {\n  // Returns hash of all intermediate hashes from targetHash to merkleRoot\n  const intermediateHashes = [`0x${targetHash}`];\n  proof.reduce((accumulator, currentValue) => {\n    const combined = combinedHash(accumulator, currentValue).toString(\"hex\");\n    intermediateHashes.push(`0x${combined}`);\n    return combined;\n  }, targetHash);\n  return intermediateHashes;\n};\nexport function* verifyCertificateNotRevoked({\n  certificate,\n  certificateStores\n}) {\n  try {\n    const targetHash = get(certificate, \"signature.targetHash\", null);\n    const proof = get(certificate, \"signature.proof\", null); // Checks if certificate and path towards merkle root has been revoked\n\n    const intermediateHashes = getIntermediateHashes(targetHash, proof);\n\n    for (let i = 0; i < intermediateHashes.length; i += 1) {\n      const hash = intermediateHashes[i]; // Check if certificate is revoked on ALL store\n\n      const revokedStatus = yield all(certificateStores.map(store => store.methods.isRevoked(hash).call()));\n      const isRevoked = revokedStatus.reduce((prev, curr) => prev || curr, false);\n      if (isRevoked) throw new Error(`Certificate has been revoked, revoked hash: ${hash}`);\n    }\n\n    yield put(verifyingCertificateRevocationSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateRevocationFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\n\nfunction isApprovedENSDomain(issuerAddress) {\n  trace(`Checking if ${issuerAddress} is opencerts TLD`);\n  const approvedENSDomains = [/(opencerts.eth)$/];\n  return some(approvedENSDomains.map(domainMask => domainMask.test(issuerAddress.toLowerCase())));\n}\n\nexport function* lookupAddressOnRegistry(ethereumAddressIssuer) {\n  const registeredIssuers = yield fetchIssuers();\n  const issuersNormalised = mapKeys(registeredIssuers, (_, k) => k.toUpperCase());\n  const identity = issuersNormalised[ethereumAddressIssuer.toUpperCase()];\n\n  if (!identity) {\n    throw new Error(`Issuer identity cannot be verified: ${ethereumAddressIssuer}`);\n  }\n\n  return identity;\n}\nexport function* resolveEnsNameToText(ensName) {\n  trace(\"resolving \", ensName);\n\n  if (!isApprovedENSDomain(ensName)) {\n    const invalidEnsError = new Error(`Issuer identity cannot be verified: ${ensName}`);\n    error(invalidEnsError);\n    throw invalidEnsError;\n  }\n\n  const getTextResult = yield call(getText, ensName, \"issuerName\");\n  trace(`Got texts records for ${ensName}`, getTextResult);\n  return getTextResult;\n}\nexport function* verifyCertificateDnsIssuer({\n  issuer\n}) {\n  const location = get(issuer, \"identityProof.location\");\n  if (!location) return false;\n  const dnsRecords = yield call(getDocumentStoreRecords, location);\n  trace(`DNS records: ${_JSON$stringify(dnsRecords)}`); // dnsRecords: [{addr: \"0xabc\", netId: 3}]\n\n  let verificationStatus = false;\n  const documentStore = getDocumentStore(issuer);\n\n  if (dnsRecords && dnsRecords.length > 0) {\n    verificationStatus = dnsRecords.find(dns => dns.addr === documentStore && dns.netId === (IS_MAINNET ? \"1\" : \"3\"));\n  }\n\n  trace(`DNS Verification Status: ${_JSON$stringify(verificationStatus)}`);\n  return verificationStatus ? location : false;\n}\nexport function* verifyCertificateRegistryIssuer({\n  issuer\n}) {\n  try {\n    const contractStoreAddresses = getDocumentStore(issuer);\n    trace(`Attempting to verify certificate issuers: ${contractStoreAddresses}`);\n    const isValidEthereumAddress = isEthereumAddress(contractStoreAddresses);\n\n    if (!isValidEthereumAddress) {\n      throw new Error(`${contractStoreAddresses} is not a valid Ethereum Address`);\n    }\n\n    trace(\"isValidEthereumAddress\", contractStoreAddresses);\n    const issuerIdentitiesFromRegistry = yield call(lookupAddressOnRegistry, contractStoreAddresses);\n    trace(`Resolved ethereum address ${contractStoreAddresses} to ${issuerIdentitiesFromRegistry}`);\n    return get(issuerIdentitiesFromRegistry, \"name\") || false;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction throwIfAnyIdentityIsNotVerified(verificationStatuses) {\n  if (verificationStatuses.length === 0) throw new Error(\"No issuers found in the document\");\n  const invalidIdentities = verificationStatuses.filter(status => !status.registry && !status.dns);\n\n  if (invalidIdentities.length > 0) {\n    const invalidStoreAddresses = invalidIdentities.map(identity => identity.documentStore);\n    throw new Error(`Issuer identity cannot be verified: ${invalidStoreAddresses.join(\", \")}`);\n  }\n}\n\nexport function* getDetailedIssuerStatus({\n  issuer\n}) {\n  const verificationStatus = {\n    documentStore: getDocumentStore(issuer),\n    registry: null,\n    dns: null\n  };\n  verificationStatus.registry = yield call(verifyCertificateRegistryIssuer, {\n    issuer\n  });\n\n  if (get(issuer, \"identityProof.type\") === \"DNS-TXT\") {\n    verificationStatus.dns = yield call(verifyCertificateDnsIssuer, {\n      issuer\n    });\n  }\n\n  trace(`issuer status: ${_JSON$stringify(verificationStatus)}`);\n  return verificationStatus;\n}\nexport function* verifyCertificateIssuer({\n  certificate\n}) {\n  try {\n    const data = getData(certificate);\n    const issuers = get(data, \"issuers\", []); // verificationStatuses: [{dns: \"abc.com\", registry:\"Govtech\", documentStore: \"0xabc\"}]\n\n    const verificationStatuses = yield all(issuers.map(issuer => call(getDetailedIssuerStatus, {\n      issuer\n    }))); // If any identity is not verified, this should return false\n\n    throwIfAnyIdentityIsNotVerified(verificationStatuses);\n    yield put(verifyingCertificateIssuerSuccess({\n      issuerIdentities: verificationStatuses\n    }));\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(verifyingCertificateIssuerFailure({\n      error: e.message\n    }));\n    return false;\n  }\n}\nexport function* verifyCertificate({\n  payload\n}) {\n  yield put({\n    type: types.VERIFYING_CERTIFICATE\n  });\n  const certificateStores = yield call(loadCertificateContracts, {\n    payload\n  });\n  const args = {\n    certificateStores,\n    certificate: payload\n  };\n  const verificationStatuses = yield all({\n    certificateIssued: call(verifyCertificateIssued, args),\n    certificateHashValid: call(verifyCertificateHash, args),\n    certificateNotRevoked: call(verifyCertificateNotRevoked, args),\n    certificateIssuerRecognised: call(verifyCertificateIssuer, args),\n    certificateStoreValid: call(verifyCertificateStore, args)\n  });\n  trace(verificationStatuses);\n  const verified = verificationStatuses.certificateIssued && verificationStatuses.certificateHashValid && verificationStatuses.certificateNotRevoked && verificationStatuses.certificateIssuerRecognised && verificationStatuses.certificateStoreValid;\n\n  if (verified) {\n    Router.push(\"/viewer\");\n  }\n}\nexport function* sendCertificate({\n  payload\n}) {\n  try {\n    const certificate = yield select(getCertificate);\n    const {\n      email,\n      captcha\n    } = payload;\n    const success = yield sendEmail({\n      certificate,\n      email,\n      captcha\n    });\n\n    if (!success) {\n      throw new Error(\"Fail to send certificate\");\n    }\n\n    yield put({\n      type: types.SENDING_CERTIFICATE_SUCCESS\n    });\n  } catch (e) {\n    yield put({\n      type: types.SENDING_CERTIFICATE_FAILURE,\n      payload: e.message\n    });\n  }\n}\nexport function* networkReset() {\n  yield put({\n    type: types.NETWORK_RESET\n  });\n}\nexport function* getAnalyticsDetails() {\n  try {\n    const rawCertificate = yield select(getCertificate);\n    const certificate = getData(rawCertificate);\n    const storeAddresses = getDocumentIssuerStores(certificate);\n    const id = get(certificate, \"id\");\n    return {\n      storeAddresses,\n      id\n    };\n  } catch (e) {\n    return {};\n  }\n}\nexport function* triggerAnalytics(errorCode) {\n  const {\n    storeAddresses,\n    id\n  } = yield call(getAnalyticsDetails);\n\n  if (storeAddresses && id) {\n    analyticsEvent(window, {\n      category: \"CERTIFICATE_ERROR\",\n      action: storeAddresses,\n      label: id,\n      value: errorCode\n    });\n  }\n}\nexport function* analyticsIssuerFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.ISSUER_IDENTITY);\n}\nexport function* analyticsHashFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_HASH);\n}\nexport function* analyticsIssuedFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.UNISSUED_CERTIFICATE);\n}\nexport function* analyticsRevocationFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.REVOKED_CERTIFICATE);\n}\nexport function* analyticsStoreFail() {\n  yield call(triggerAnalytics, ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_STORE);\n}\nexport default [takeEvery(types.UPDATE_CERTIFICATE, verifyCertificate), takeEvery(types.SENDING_CERTIFICATE, sendCertificate), takeEvery(applicationTypes.UPDATE_WEB3, networkReset), takeEvery(types.VERIFYING_CERTIFICATE_ISSUER_FAILURE, analyticsIssuerFail), takeEvery(types.VERIFYING_CERTIFICATE_REVOCATION_FAILURE, analyticsRevocationFail), takeEvery(types.VERIFYING_CERTIFICATE_ISSUED_FAILURE, analyticsIssuedFail), takeEvery(types.VERIFYING_CERTIFICATE_HASH_FAILURE, analyticsHashFail), takeEvery(types.VERIFYING_CERTIFICATE_STORE_FAILURE, analyticsStoreFail)];","map":{"version":3,"sources":["/home/ajl/development/ssi/academic-creds/convergence-credentials.github.io/src/sagas/certificate.js"],"names":["some","get","partition","compact","mapKeys","put","all","call","select","takeEvery","getData","verifySignature","isValidAddress","isEthereumAddress","Router","getDocumentStoreRecords","getLogger","types","verifyingCertificateIssuerSuccess","verifyingCertificateIssuerFailure","verifyingCertificateRevocationSuccess","verifyingCertificateRevocationFailure","verifyingCertificateIssuedSuccess","verifyingCertificateIssuedFailure","verifyingCertificateHashSuccess","verifyingCertificateHashFailure","verifyingCertificateStoreSuccess","verifyingCertificateStoreFailure","getCertificate","applicationTypes","DocumentStoreDefinition","fetchIssuers","combinedHash","ensResolveAddress","getText","sendEmail","analyticsEvent","getDocumentStore","getDocumentIssuerStores","getSelectedWeb3","IS_MAINNET","trace","error","ANALYTICS_VERIFICATION_ERROR_CODE","ISSUER_IDENTITY","CERTIFICATE_HASH","UNISSUED_CERTIFICATE","REVOKED_CERTIFICATE","CERTIFICATE_STORE","loadCertificateContracts","payload","data","unresolvedContractStoreAddresses","map","issuer","web3","contractStoreAddresses","unresolvedAddress","abi","contracts","address","eth","Contract","type","LOADING_STORE_SUCCESS","e","LOADING_STORE_FAILURE","isValidENSDomain","storeAddress","Error","ensToAddress","ens","getAddress","isValidSmartContract","supportedContractHashes","onChainByteCode","getCode","hashOfOnChainByteCode","utils","keccak256","includes","verifyCertificateStore","certificate","ethereumAddressIssuers","unresolvedEnsNames","resolvedEnsNames","unresolvedEnsName","combinedStoreAddresses","concat","message","verifyCertificateHash","verified","hashError","verifyCertificateIssued","certificateStores","merkleRoot","issuedStatuses","store","methods","isIssued","length","reduce","prev","curr","getIntermediateHashes","targetHash","proof","intermediateHashes","accumulator","currentValue","combined","toString","push","verifyCertificateNotRevoked","i","hash","revokedStatus","isRevoked","isApprovedENSDomain","issuerAddress","approvedENSDomains","domainMask","test","toLowerCase","lookupAddressOnRegistry","ethereumAddressIssuer","registeredIssuers","issuersNormalised","_","k","toUpperCase","identity","resolveEnsNameToText","ensName","invalidEnsError","getTextResult","verifyCertificateDnsIssuer","location","dnsRecords","verificationStatus","documentStore","find","dns","addr","netId","verifyCertificateRegistryIssuer","isValidEthereumAddress","issuerIdentitiesFromRegistry","throwIfAnyIdentityIsNotVerified","verificationStatuses","invalidIdentities","filter","status","registry","invalidStoreAddresses","join","getDetailedIssuerStatus","verifyCertificateIssuer","issuers","issuerIdentities","verifyCertificate","VERIFYING_CERTIFICATE","args","certificateIssued","certificateHashValid","certificateNotRevoked","certificateIssuerRecognised","certificateStoreValid","sendCertificate","email","captcha","success","SENDING_CERTIFICATE_SUCCESS","SENDING_CERTIFICATE_FAILURE","networkReset","NETWORK_RESET","getAnalyticsDetails","rawCertificate","storeAddresses","id","triggerAnalytics","errorCode","window","category","action","label","value","analyticsIssuerFail","analyticsHashFail","analyticsIssuedFail","analyticsRevocationFail","analyticsStoreFail","UPDATE_CERTIFICATE","SENDING_CERTIFICATE","UPDATE_WEB3","VERIFYING_CERTIFICATE_ISSUER_FAILURE","VERIFYING_CERTIFICATE_REVOCATION_FAILURE","VERIFYING_CERTIFICATE_ISSUED_FAILURE","VERIFYING_CERTIFICATE_HASH_FAILURE","VERIFYING_CERTIFICATE_STORE_FAILURE"],"mappings":"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","sourcesContent":["import { some, get, partition, compact, mapKeys } from \"lodash\";\nimport { put, all, call, select, takeEvery } from \"redux-saga/effects\";\nimport { getData, verifySignature } from \"@govtechsg/open-attestation\";\nimport { isValidAddress as isEthereumAddress } from \"ethereumjs-util\";\nimport Router from \"next/router\";\nimport { getDocumentStoreRecords } from \"@govtechsg/dnsprove\";\nimport { getLogger } from \"../utils/logger\";\nimport {\n  types,\n  verifyingCertificateIssuerSuccess,\n  verifyingCertificateIssuerFailure,\n  verifyingCertificateRevocationSuccess,\n  verifyingCertificateRevocationFailure,\n  verifyingCertificateIssuedSuccess,\n  verifyingCertificateIssuedFailure,\n  verifyingCertificateHashSuccess,\n  verifyingCertificateHashFailure,\n  verifyingCertificateStoreSuccess,\n  verifyingCertificateStoreFailure,\n  getCertificate\n} from \"../reducers/certificate\";\nimport { types as applicationTypes } from \"../reducers/application\";\nimport DocumentStoreDefinition from \"../services/contracts/DocumentStore.json\";\nimport fetchIssuers from \"../services/issuers\";\nimport { combinedHash } from \"../utils\";\nimport { ensResolveAddress, getText } from \"../services/ens\";\nimport sendEmail from \"../services/email\";\nimport { analyticsEvent } from \"../components/Analytics\";\nimport {\n  getDocumentStore,\n  getDocumentIssuerStores\n} from \"../utils/certificate\";\nimport { getSelectedWeb3 } from \"./application\";\nimport { IS_MAINNET } from \"../config\";\n\nconst { trace, error } = getLogger(\"saga:certificate\");\n\nconst ANALYTICS_VERIFICATION_ERROR_CODE = {\n  ISSUER_IDENTITY: 0,\n  CERTIFICATE_HASH: 1,\n  UNISSUED_CERTIFICATE: 2,\n  REVOKED_CERTIFICATE: 3,\n  CERTIFICATE_STORE: 4\n};\n\nexport function* loadCertificateContracts({ payload }) {\n  try {\n    const data = getData(payload);\n    trace(`Loading certificate: ${data}`);\n    const unresolvedContractStoreAddresses = get(data, \"issuers\", []).map(\n      issuer => getDocumentStore(issuer)\n    );\n    const web3 = yield getSelectedWeb3();\n    const contractStoreAddresses = yield all(\n      unresolvedContractStoreAddresses.map(unresolvedAddress =>\n        call(ensResolveAddress, unresolvedAddress)\n      )\n    );\n    trace(`Resolved certificate's store addresses, ${contractStoreAddresses}`);\n\n    const { abi } = DocumentStoreDefinition;\n\n    const contracts = contractStoreAddresses.map(\n      address => new web3.eth.Contract(abi, address)\n    );\n\n    yield put({\n      type: types.LOADING_STORE_SUCCESS\n    });\n    return contracts;\n  } catch (e) {\n    yield put({\n      type: types.LOADING_STORE_FAILURE,\n      payload: e\n    });\n    return null;\n  }\n}\n\nexport function* isValidENSDomain(storeAddress) {\n  trace(`Checking if ${storeAddress} is a valid ENS Domain`);\n  if (storeAddress == null) {\n    throw new Error(\"No address in certificate\");\n  }\n  const web3 = yield getSelectedWeb3();\n  const ensToAddress = yield web3.eth.ens.getAddress(storeAddress);\n  if (ensToAddress === null) {\n    throw new Error(\"Invalid ENS\");\n  }\n  return ensToAddress;\n}\n\nexport function* isValidSmartContract(storeAddress) {\n  const web3 = yield getSelectedWeb3();\n  const supportedContractHashes = [\n    \"0x7135575eac76f1817c27b06c452bdc2b7e1b13240797415684e227def063a127\"\n  ];\n  const onChainByteCode = yield web3.eth.getCode(storeAddress);\n  const hashOfOnChainByteCode = web3.utils.keccak256(onChainByteCode);\n  if (!supportedContractHashes.includes(hashOfOnChainByteCode)) {\n    throw new Error(\"Invalid smart contract: \"`${storeAddress}`);\n  }\n  return true;\n}\n\nexport function* verifyCertificateStore({ certificate }) {\n  try {\n    const data = getData(certificate);\n\n    const contractStoreAddresses = get(data, \"issuers\", []).map(issuer =>\n      getDocumentStore(issuer)\n    );\n    trace(`Attempting to verify certificate store: ${contractStoreAddresses}`);\n\n    const [ethereumAddressIssuers, unresolvedEnsNames] = partition(\n      contractStoreAddresses,\n      isEthereumAddress\n    );\n    trace(\"ethereumAddressIssuers\", ethereumAddressIssuers);\n    trace(\"unresolvedEnsNames\", unresolvedEnsNames);\n\n    const resolvedEnsNames = yield unresolvedEnsNames.map(unresolvedEnsName =>\n      call(isValidENSDomain, unresolvedEnsName)\n    );\n\n    // Concat the 2 arrays\n    const combinedStoreAddresses = compact(\n      ethereumAddressIssuers.concat(resolvedEnsNames)\n    );\n\n    // Checks if issuing institution has a valid smart contract with OpenCerts\n    yield combinedStoreAddresses.map(address => isValidSmartContract(address));\n    yield put(verifyingCertificateStoreSuccess());\n    return combinedStoreAddresses;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateStoreFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nexport function* verifyCertificateHash({ certificate }) {\n  const verified = verifySignature(certificate);\n\n  if (verified) {\n    yield put(verifyingCertificateHashSuccess());\n\n    return true;\n  }\n  const hashError = new Error(\"Certificate data does not match target hash\");\n  error(hashError);\n  yield put(\n    verifyingCertificateHashFailure({\n      error: hashError.message\n    })\n  );\n  return false;\n}\n\nexport function* verifyCertificateIssued({ certificate, certificateStores }) {\n  try {\n    const merkleRoot = `0x${get(certificate, \"signature.merkleRoot\", \"\")}`;\n\n    // Checks if certificate has been issued on ALL store\n    const issuedStatuses = yield all(\n      certificateStores.map(store => store.methods.isIssued(merkleRoot).call())\n    );\n    if (issuedStatuses.length === 0) throw new Error(\"Invalid file\");\n    const isIssued = issuedStatuses.reduce((prev, curr) => prev && curr, true);\n    if (!isIssued) throw new Error(\"Certificate has not been issued\");\n    yield put(verifyingCertificateIssuedSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateIssuedFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nexport const getIntermediateHashes = (targetHash, proof = []) => {\n  // Returns hash of all intermediate hashes from targetHash to merkleRoot\n  const intermediateHashes = [`0x${targetHash}`];\n\n  proof.reduce((accumulator, currentValue) => {\n    const combined = combinedHash(accumulator, currentValue).toString(\"hex\");\n    intermediateHashes.push(`0x${combined}`);\n    return combined;\n  }, targetHash);\n\n  return intermediateHashes;\n};\n\nexport function* verifyCertificateNotRevoked({\n  certificate,\n  certificateStores\n}) {\n  try {\n    const targetHash = get(certificate, \"signature.targetHash\", null);\n    const proof = get(certificate, \"signature.proof\", null);\n\n    // Checks if certificate and path towards merkle root has been revoked\n    const intermediateHashes = getIntermediateHashes(targetHash, proof);\n\n    for (let i = 0; i < intermediateHashes.length; i += 1) {\n      const hash = intermediateHashes[i];\n\n      // Check if certificate is revoked on ALL store\n      const revokedStatus = yield all(\n        certificateStores.map(store => store.methods.isRevoked(hash).call())\n      );\n      const isRevoked = revokedStatus.reduce(\n        (prev, curr) => prev || curr,\n        false\n      );\n      if (isRevoked)\n        throw new Error(`Certificate has been revoked, revoked hash: ${hash}`);\n    }\n\n    yield put(verifyingCertificateRevocationSuccess());\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateRevocationFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nfunction isApprovedENSDomain(issuerAddress) {\n  trace(`Checking if ${issuerAddress} is opencerts TLD`);\n  const approvedENSDomains = [/(opencerts.eth)$/];\n  return some(\n    approvedENSDomains.map(domainMask =>\n      domainMask.test(issuerAddress.toLowerCase())\n    )\n  );\n}\n\nexport function* lookupAddressOnRegistry(ethereumAddressIssuer) {\n  const registeredIssuers = yield fetchIssuers();\n  const issuersNormalised = mapKeys(registeredIssuers, (_, k) =>\n    k.toUpperCase()\n  );\n\n  const identity = issuersNormalised[ethereumAddressIssuer.toUpperCase()];\n  if (!identity) {\n    throw new Error(\n      `Issuer identity cannot be verified: ${ethereumAddressIssuer}`\n    );\n  }\n  return identity;\n}\n\nexport function* resolveEnsNameToText(ensName) {\n  trace(\"resolving \", ensName);\n  if (!isApprovedENSDomain(ensName)) {\n    const invalidEnsError = new Error(\n      `Issuer identity cannot be verified: ${ensName}`\n    );\n    error(invalidEnsError);\n    throw invalidEnsError;\n  }\n\n  const getTextResult = yield call(getText, ensName, \"issuerName\");\n  trace(`Got texts records for ${ensName}`, getTextResult);\n  return getTextResult;\n}\n\nexport function* verifyCertificateDnsIssuer({ issuer }) {\n  const location = get(issuer, \"identityProof.location\");\n\n  if (!location) return false;\n\n  const dnsRecords = yield call(getDocumentStoreRecords, location);\n\n  trace(`DNS records: ${JSON.stringify(dnsRecords)}`); // dnsRecords: [{addr: \"0xabc\", netId: 3}]\n  let verificationStatus = false;\n  const documentStore = getDocumentStore(issuer);\n  if (dnsRecords && dnsRecords.length > 0) {\n    verificationStatus = dnsRecords.find(\n      dns =>\n        dns.addr === documentStore && dns.netId === (IS_MAINNET ? \"1\" : \"3\")\n    );\n  }\n  trace(`DNS Verification Status: ${JSON.stringify(verificationStatus)}`);\n  return verificationStatus ? location : false;\n}\n\nexport function* verifyCertificateRegistryIssuer({ issuer }) {\n  try {\n    const contractStoreAddresses = getDocumentStore(issuer);\n    trace(\n      `Attempting to verify certificate issuers: ${contractStoreAddresses}`\n    );\n    const isValidEthereumAddress = isEthereumAddress(contractStoreAddresses);\n\n    if (!isValidEthereumAddress) {\n      throw new Error(\n        `${contractStoreAddresses} is not a valid Ethereum Address`\n      );\n    }\n\n    trace(\"isValidEthereumAddress\", contractStoreAddresses);\n\n    const issuerIdentitiesFromRegistry = yield call(\n      lookupAddressOnRegistry,\n      contractStoreAddresses\n    );\n    trace(\n      `Resolved ethereum address ${contractStoreAddresses} to ${issuerIdentitiesFromRegistry}`\n    );\n    return get(issuerIdentitiesFromRegistry, \"name\") || false;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction throwIfAnyIdentityIsNotVerified(verificationStatuses) {\n  if (verificationStatuses.length === 0)\n    throw new Error(\"No issuers found in the document\");\n  const invalidIdentities = verificationStatuses.filter(\n    status => !status.registry && !status.dns\n  );\n  if (invalidIdentities.length > 0) {\n    const invalidStoreAddresses = invalidIdentities.map(\n      identity => identity.documentStore\n    );\n    throw new Error(\n      `Issuer identity cannot be verified: ${invalidStoreAddresses.join(\", \")}`\n    );\n  }\n}\n\nexport function* getDetailedIssuerStatus({ issuer }) {\n  const verificationStatus = {\n    documentStore: getDocumentStore(issuer),\n    registry: null,\n    dns: null\n  };\n\n  verificationStatus.registry = yield call(verifyCertificateRegistryIssuer, {\n    issuer\n  });\n\n  if (get(issuer, \"identityProof.type\") === \"DNS-TXT\") {\n    verificationStatus.dns = yield call(verifyCertificateDnsIssuer, {\n      issuer\n    });\n  }\n  trace(`issuer status: ${JSON.stringify(verificationStatus)}`);\n  return verificationStatus;\n}\n\nexport function* verifyCertificateIssuer({ certificate }) {\n  try {\n    const data = getData(certificate);\n    const issuers = get(data, \"issuers\", []);\n    // verificationStatuses: [{dns: \"abc.com\", registry:\"Govtech\", documentStore: \"0xabc\"}]\n    const verificationStatuses = yield all(\n      issuers.map(issuer => call(getDetailedIssuerStatus, { issuer }))\n    );\n\n    // If any identity is not verified, this should return false\n    throwIfAnyIdentityIsNotVerified(verificationStatuses);\n\n    yield put(\n      verifyingCertificateIssuerSuccess({\n        issuerIdentities: verificationStatuses\n      })\n    );\n    return true;\n  } catch (e) {\n    error(e);\n    yield put(\n      verifyingCertificateIssuerFailure({\n        error: e.message\n      })\n    );\n    return false;\n  }\n}\n\nexport function* verifyCertificate({ payload }) {\n  yield put({\n    type: types.VERIFYING_CERTIFICATE\n  });\n  const certificateStores = yield call(loadCertificateContracts, { payload });\n  const args = { certificateStores, certificate: payload };\n\n  const verificationStatuses = yield all({\n    certificateIssued: call(verifyCertificateIssued, args),\n    certificateHashValid: call(verifyCertificateHash, args),\n    certificateNotRevoked: call(verifyCertificateNotRevoked, args),\n    certificateIssuerRecognised: call(verifyCertificateIssuer, args),\n    certificateStoreValid: call(verifyCertificateStore, args)\n  });\n  trace(verificationStatuses);\n  const verified =\n    verificationStatuses.certificateIssued &&\n    verificationStatuses.certificateHashValid &&\n    verificationStatuses.certificateNotRevoked &&\n    verificationStatuses.certificateIssuerRecognised &&\n    verificationStatuses.certificateStoreValid;\n  if (verified) {\n    Router.push(\"/viewer\");\n  }\n}\n\nexport function* sendCertificate({ payload }) {\n  try {\n    const certificate = yield select(getCertificate);\n    const { email, captcha } = payload;\n    const success = yield sendEmail({\n      certificate,\n      email,\n      captcha\n    });\n\n    if (!success) {\n      throw new Error(\"Fail to send certificate\");\n    }\n\n    yield put({\n      type: types.SENDING_CERTIFICATE_SUCCESS\n    });\n  } catch (e) {\n    yield put({\n      type: types.SENDING_CERTIFICATE_FAILURE,\n      payload: e.message\n    });\n  }\n}\n\nexport function* networkReset() {\n  yield put({\n    type: types.NETWORK_RESET\n  });\n}\n\nexport function* getAnalyticsDetails() {\n  try {\n    const rawCertificate = yield select(getCertificate);\n    const certificate = getData(rawCertificate);\n\n    const storeAddresses = getDocumentIssuerStores(certificate);\n    const id = get(certificate, \"id\");\n    return { storeAddresses, id };\n  } catch (e) {\n    return {};\n  }\n}\n\nexport function* triggerAnalytics(errorCode) {\n  const { storeAddresses, id } = yield call(getAnalyticsDetails);\n  if (storeAddresses && id) {\n    analyticsEvent(window, {\n      category: \"CERTIFICATE_ERROR\",\n      action: storeAddresses,\n      label: id,\n      value: errorCode\n    });\n  }\n}\n\nexport function* analyticsIssuerFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.ISSUER_IDENTITY\n  );\n}\n\nexport function* analyticsHashFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_HASH\n  );\n}\n\nexport function* analyticsIssuedFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.UNISSUED_CERTIFICATE\n  );\n}\n\nexport function* analyticsRevocationFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.REVOKED_CERTIFICATE\n  );\n}\n\nexport function* analyticsStoreFail() {\n  yield call(\n    triggerAnalytics,\n    ANALYTICS_VERIFICATION_ERROR_CODE.CERTIFICATE_STORE\n  );\n}\n\nexport default [\n  takeEvery(types.UPDATE_CERTIFICATE, verifyCertificate),\n  takeEvery(types.SENDING_CERTIFICATE, sendCertificate),\n  takeEvery(applicationTypes.UPDATE_WEB3, networkReset),\n\n  takeEvery(types.VERIFYING_CERTIFICATE_ISSUER_FAILURE, analyticsIssuerFail),\n  takeEvery(\n    types.VERIFYING_CERTIFICATE_REVOCATION_FAILURE,\n    analyticsRevocationFail\n  ),\n  takeEvery(types.VERIFYING_CERTIFICATE_ISSUED_FAILURE, analyticsIssuedFail),\n  takeEvery(types.VERIFYING_CERTIFICATE_HASH_FAILURE, analyticsHashFail),\n  takeEvery(types.VERIFYING_CERTIFICATE_STORE_FAILURE, analyticsStoreFail)\n];\n"]},"metadata":{},"sourceType":"module"}